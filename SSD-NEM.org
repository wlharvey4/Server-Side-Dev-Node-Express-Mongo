# -*- mode:org; -*-

#+title:Server-Side Development with NodeJS, Express, and MongoDB
#+author:The Hong Kong University of Science and Technology
#+date:2019-12-14 08:05
#+subtitle: {{{version}}} {{{date}}}
#+macro:version Version 0.0.21

#+texinfo: @insertcopying

* About the Course
:PROPERTIES:
:unnumbered: t
:END:

This course deals with all things server-side.  We base the entire course
around the NodeJS platform.  We start with a brief overview of the Web
protocols: HTTP and HTTPS.  We examine NodeJS and NodeJS modules: Express for
building web servers.  On the database side, we review basic CRUD operations,
NoSQL databases, in particular MongoDB and Mongoose for accessing MongoDB from
NodeJS.  We examine the REST concepts and building a RESTful API.  We touch
upon authentication and security. Finally we review backend as a service (BaaS)
approaches, including mobile BaaS, both open-source and commercial BaaS
services.

At the end of this course, you will be able to:

- Demonstrate an understanding of server-side concepts, CRUD and REST

- Build and configure a backend server using NodeJS framework

- Build a RESTful API for the front-end to access backend services


{{{heading(This course is part of multiple programs)}}}

This course can be applied to multiple Specializations or Professional
Certificates programs.  Completing this course will count towards your learning
in any of the following programs:

- [[https://www.coursera.org/specializations/full-stack-react][Full-Stack Web Development with React Specialization]]

- [[https://www.coursera.org/specializations/full-stack-mobile-app-development][Full Stack Web and Multiplatform Mobile App Development Specialization]]

** Welcome from the Instructor
:PROPERTIES:
:instructor: Jogesh K. Muppala
:unnumbered: t
:END:

Welcome to Server-side Development with NodeJS, Express and MongoDB!  You’re
joining thousands of learners currently enrolled in the course.  I'm excited to
have you in the class and look forward to your contributions to the learning
community.

To begin, I recommend taking a few minutes to explore the course site.  Review
the material we’ll cover each week, and preview the assignments you’ll need to
complete to pass the course.  Click Discussions to see forums where you can
discuss the course material with fellow students taking the class.

If you have questions about course content, please post them in the forums to
get help from others in the course community.  For technical problems with the
Coursera platform, visit the Learner Help Center.

Good luck as you get started, and I hope you enjoy the course!

* Week 1---Introduction to Server-Side Development-NodeJS
:PROPERTIES:
:length:   10h 37m
:END:

{{{heading(Learning Objectives)}}}

- Describe the use of Node for server-side development
- Create a Node application
- Demonstrate the use of Node modules in developing a Node application
- Develop a simple REST API server using the Express framework

** Server-Side Development with NodeJS, Express and MongoDB
:PROPERTIES:
:length:   10m
:END:

[[file:resources/week_1-lecture_01.mp4]]

** Introduction to the Learning Resources

[[file:resources/week_1-lecture_02.mp4]]

*** Additional Resources
- [[https://nodejs.org/][NodeJS]]

- [[https://www.npmjs.com/][NPM]]

- [[http://expressjs.com/][ExpressJS]]

- [[http://www.mongodb.org/][MongoDB]]

- [[http://mongoosejs.com/][Mongoose]]

** Full-Stack Web Development

{{{heading(The Big Picture---Objectives and Outcomes)}}}

This lesson gives you a big picture view of the Full Stack Web Development.
The lecture gives you an overview of full stack web development.  At the end of
this lesson, you will be able to:

- Understand what is meant by full stack in the context of web development

- Distinguish between front-end, back-end and full stack web development

- Understand the position of this course in the context of this specialization

- [[file:resources/week_1/lecture_03/index.mp4]]


{{{heading(Useful Links)}}}

- [[http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/][What is a Full Stack developer?]]

  A Full Stack Developer is someone with familiarity in each layer, if not
  mastery in many and a genuine interest in all software technology.  Good
  developers who are familiar with the entire stack know how to make life
  easier for those around them.

- [[http://edward-designer.com/web/full-stack-web-developer/][Wait, Wait… What is a Full-stack Web Developer After All?]]

- [[http://andyshora.com/full-stack-developers.html][The Myth of the Full-stack Developer]]

- [[https://en.wikipedia.org/wiki/Multitier_architecture][Multi-tier Architecture]]

- [[http://www.tonymarston.net/php-mysql/3-tier-architecture.html][What is the 3-Tier Architecture?]]

*** Layers of the Full Stack
1. Server, Network, and Hosting Environment.

   - This involves understanding what can break and why, taking no resource for
     granted.

   - Appropriate use of the file system, cloud storage, network resources, and
     an understanding of data redundancy and availability is necessary.

   - How does the application scale given the hardware constraints?

   - What about multi-threading and race  conditions? Guess what, you won’t see
     those on your development machine, but they  can and do happen in the real
     world.

   - Full stack developers can work side by side with DevOps.  The system
     should provide useful error messages and logging capabilities. DevOps will
     see the messages before you will, so make them count.

2. Data Modeling

   - If the data model is flawed, the business logic and higher layers start to
     need strange (ugly) code to compensate for corner cases the data model
     doesn’t cover.

   - Full stack developers know how to create a reasonably normalized
     relational model, complete with foreign keys, indexes, views, lookup
     tables, etc.

   - Full stack developers are familiar with the concept of non-relational data
     stores and understand where they shine over relational data stores.

3. Business Logic

   - The heart of the value the application provides.

   - Solid object oriented skills are needed here.

   - Frameworks might be needed here as well.

4. API layer---Action Layer---MVC

   - How the outside world operates against the business logic and data model.

   - Frameworks at this level should be used heavily.

   - Full stack developers have the ability to write clear, consistent, simple
     to use interfaces. The heights to which some APIs are convoluted repel me.

5. User Interface

   - Full stack developers: a) understand how to create a readable layout, or
     b) acknowledge they need help from artists and graphic designers.  Either
     way, implementing a good visual design is key.

   - Can include mastery of HTML5 / CSS.

   - JavaScript is the up and coming language of the future and lots of
     exciting work is being done in the JavaScript world (node, backbone,
     knockout…)

6. User Experience

   - Full stack developers appreciate that users just want things to work.

   - A good system doesn’t give its users carpal tunnel syndrome or sore eyes.
     A full stack developer can step back and look at a process that needs 8
     clicks and 3 steps, and get it down to one click.  Full stack developers
     write useful error messages. If something breaks, be apologetic about
     it. Sometimes programmers inadvertently write error messages that can make
     people feel stupid.

7. Understanding what the customer and the business need

   - Now we are blurring into the line of architect, but that is too much of a
     hands off role.

   - Full stack developers have a grasp of what is going on in the field when
     the customer uses the software. They also have a grasp of the business.

8. Other Pieces of the Puzzle

   - Ability to write quality unit tests.  By the way, even JavaScript can have
     unit tests these days.

   - Understanding of repeatable automated processes for building the
     application, testing it, documenting it, and deploying it at scale.

   - An awareness of security concerns is important, as each layer presents its
     own possible vulnerabilities.

9. Closing Thoughts

   - It is very bad practice to tightly couple code to a specific
     implementation (library, OS, hardware, etc). Just because a full stack
     developer understands the entire spectrum doesn’t mean they have license
     to take shortcuts. Well, actually they do if it is a build and throw away
     prototype.

   - Technology start-ups need full stack developers for their versatility!
     However, as an organization matures, it needs more and more focused
     skills.

   - I’m not sure you can call yourself a full stack developer until you have
     worked in multiple languages, platforms, and even industries in your
     professional career. Full stack goes beyond a ‘senior engineer’, as it is
     along the same lines as a polyglot programmer but with a higher view of
     all the connecting pieces. Note that on my list, only items 3-5 involve
     writing code.

*** What is a Full Stack Web Developer
:PROPERTIES:
:url:      https://edward-designer.com/web/full-stack-web-developer/
:author:   Edward Chung
:date:     December 18, 2014
:END:

**** Summary of What is a Full Stack Web Developer
A full-stack web developer is someone who has honed skills in both front-end
web design/development and back-end/server coding.  You can count on a
full-stack web developer to design, code, implement and maintain a fully
functional modern interactive website on his/her own (not just a static website
with a few pages).

**** The Full Stack Web Developer
With the ever evolvement of the almighty World Wide Web, new job functions are
created virtually every day.  Just a few years ago, you only needed a web
designer to create the visual design in Photoshop and/or Dreamweaver and a web
developer to code the front-end/back-end scripts and the website was ready to
go.  At that time, websites were charged based on the number of “pages” (a
concept borrowed from print design).

Fast forward to the present, we now have (not a exhaustive list) :

- visual designer
- web designer
- UI designer
- UX designer
- interaction designer
- art director
- front-end developer
- back-end developer
- web developer
- mobile developer
- database developer
- database administrator
- web master
- web server administrator
- SEO specialist
- web analyst
- web security professional
- quality assurance tester
- project manager
- growth hacker
- …


Several roles may be taken up by the same individual depending on the size of
the company and the resources.  Very large and profitable companies may gather
experts from each field in their teams with a view to create the
best-ever-possible web products of the world.

But normally, in the down-to-earth company, the web designer/developer
distinction still applies.  The web designer will be responsible for the
visual/web/UI/UX/interaction design while the web developer will do the
front-end coding/back-end coding/database administration/server
setup/debugging/etc.  However, problems always occur in areas when the two have
to work together yet only either one takes responsible.  Factors like
miscommunications/false assumptions of job role and scope/misunderstanding of
the technology/etc.  will render the end product a subpar one.

This is where a full-stack web developer can fill the gap.  A full-stack web
developer masters the best of both worlds (or to a minimum understands both
worlds).  (S)He will be able to steer the web projects in the right direction
utilizing the best practices and latest advancements in the technology.  (S)He
will design and code the whole web project themselves or supervise others to
perform the tasks by overlooking the whole process from scratch to finish.

When websites and web applications become more and more interactive and
sophisticated, understanding the technical capabilities of the systems and
having an eye for artistic/usability judgement are critical to the success.  So
it is natural for web professionals to evolve to full-stack web developers in
due course.

However, designing and coding are two distinct skills that require different
regions of the brain to master. The right brain is for visual and creativity
and the left brain is for structure and organization.  Designers are
predominately right-brainers while coder left-brainers.  So there is still only
a handful of full-stack web developer on the market.

{{{heading(Benefits of Being a Full-Stack Web Developer)}}}

1. You can build a professional website from scratches for your employer.

2. You can be a competent member in cross-functional Agile teams where you can
   perform both front-end and back-end development.  As Agile project
   management is fast becoming the norm for web application development and
   UI/UX is gaining in importance for the success or failure of any web
   application, you will be seen as a valuable team member contributing to the
   success of projects.

3. You can start your own website design and development business.

4. You can build your own websites and monetize them through Adsense, affiliate
   marketing, selling your own products and more.  The best of this is the
   flexibility of earning extra money alongside your regular job.  There are
   many great examples of web developers turning this business into a career
   and quitting their regular jobs.

*** The Myth of the Full-stack Developer
:PROPERTIES:
:url:      https://www.andyshora.com/full-stack-developers.html
:author:   Andy Shora
:END:

{{{heading(“Full Stack”)}}}

My defensive tendencies are normally put on high alert when I hear that magic
phrase.  Stacks are a lot bigger than what they used to be, and being able to
claim one has acquired refined skills at every layer of web development is
certainly not a small claim.  Does this mean you have a broad range of skills
or you specialise in everything?

For a time (allegedly) Facebook only hired full-stack engineers.  This was of
course when they were building the first few versions of Facebook, which, lets
face it had a relatively simple php backend and wasn't anything special
design-wise.

{{{heading(Full-stack used to mean less layers)}}}

Coding php or Python, jQuery, HTML, CSS then transferring a few files via FTP
to your shared hosting account or dedicated server? You were full-stack.  HTML
was trivial, and even thinking of implementing any proper application code in
JavaScript wasn't possible.

My beef is not with people who can do all of the above, it's with the label
'full-stack developer'.  What does it mean in 2014?

At the level of a senior full-stack engineer we're perhaps talking about
architecting a modular Backbone/AngularJS front-end whilst optimising content
delivery and tweaking hardware accelerated layers in CSS, followed by
implementing an async non-blocking backend (which also pre-renders templates on
the server), and pushing to an AWS cluster which has been built with security
and scaleability in mind.  Not to mention design.  Designing UI responsively
and mobile-first is essential, utilising a CSS pre-processor to save time.  And
remember to setup Nagios for monitoring.  Oh, and ideally when the Continuous
Integration server detects a bad build because your end-to-end tests have
failed, get it to send you an SMS with the build error messages.  Well, the
last two are probably for bonus points.

Ask someone who labels themselves 'full-stack'.  Do they believe they have
familiarity with different layers, or true mastery?

{{{heading(Identifying mastery)}}}

I used to work with a very smart guy who when interviewing junior web
developers, used to draw a spider diagram with each of the spikes being
different layers of web development; UX, HTML, CSS, JavaScript, backend
scripting language, and SQL.  When the young developers were asked to grade
themselves out of 10 for each of the skill areas, most went for a good spread,
but a rather high spread.  It seemed nobody wanted to exceed an 8, or drop
below a 5 in any of the layers.  We can ignore the scale at which they were
grading themselves, because we were simply interpreting the grades relatively
against each other so we could get a good idea of what kind of developer the
individual saw themselves as.  I didn't hear the term 'full-stack' being used
even once, but we got a feel that everyone was an all-round web developer.
What happened next was more interesting.

On the second iteration the interviewees were given a maximum of 30 points to
distribute as they pleased.  After some frowning, some internal arguing, and
finally the self-grading we saw a lot more skewed graphs.  The 7-5 well-spread
ratings turned into more skewed 8-2's.  It seemed when faced with the harsh
reality of admitting what they were really good at, they delivered, giving
themselves 8's in their favoured areas and 2's in others.  If the candidates
really believed in their initial relative spread, we would see the same
weighting in the second round, but instead we saw front-end and back-end
developers emerge from the crowd.

Of course 99% of web developers have probably never sat through this test, and
have perhaps have never been forced to reveal what their real spread of skills
is.

{{{heading(How skilled are you in each discipline?)}}}

The basics of the languages/frameworks we learn today can often be picked up in
a matter of hours.  We no longer add skills to our CVs by taking a course, we
simply download some code and start hacking through tutorials and demo code.
The problem is, I feel the difference between knowing something in web
development and truly mastering it is now becoming an increasingly blurred
line.

It's very easy to become disillusioned with your own skills when you've
deployed some code which has been consumed by lots of users.  Let's say you've
written a web application which has scaled well under load, and you've received
great feedback.  Are you a master of everything you used in this stack?  Or are
you simply good at implementing the layers you needed to make things work
together?  Because that's an entirely different skill, and in fact a very
valuable one.

{{{heading(The skill of acquiring new skills)}}}

In my eyes the most valuable skill to have is the ability to learn, closely
followed by the ability to know when you don't know something.  I'm sure we've
all met people who decide to put brakes on their own learning because they
believe they've become a master at something.  I don't know about you, but the
smartest people I know (and the ones I have most respect for) are the ones who
are still eager to learn new things every day, from everyone they meet.  These
people just don't stop growing, in terms of both ability and character.

{{{heading(Why I'm not a full-stack developer)}}}

At one point (probably when I was about twenty-two) I heard this phrase
'full-stack' and I thought "yeah, I'm one of them".  Five years later after
working in roles with ASP, php, .Net, Node and finally JavaScript and CSS, I
only label myself as a front-end developer.  Maybe I just wasn't that good at
previous disciplines, or maybe since spending the last 2-3 years in pure
JavaScript roles I just actually realised how high the limits are when you
specialise.  This is simply opportunity I did not have when I was busy in
cross-discipline roles at smaller companies.

Sure, I've got some broad skills like a lot of developers.  However, I'd like
to think being a front-end developer now assumes some knowledge of UX, design,
and how data is modelled and served on the backend, and this is why I think the
term full-stack is old fashioned (if five years is old) and perhaps a bit smug.

Maybe, I just don't like the term.

{{{heading(Some people are willing to have a go at everything)}}}

Perhaps most respectable about all people who claim to be full-stack, is that
is conveys ambition and persistance.  The ideal developer should be willing to
have a go at learning anything, but also acknowledge when they need help from a
specialist in the team.

Perhaps I was too defensive at first, I've met too many people who pronounce
the term in a smug way, instantly causing me to discredit them.  However, say
you're full-stack in a normal way, and there will be no scrutiny from my part.
It won't be at all like meeting an investment banker or recruiter.

{{{heading(The employability of a true full-stack developer: HIGH)}}}

The chances of finding a good full-stack developer: LOW.

Smaller companies and startups NEED full-stack developers.  Developers are
often forced to acquire new skills when the resources simply aren't available.
I feel the problem for companies desperate to hire these guys and girls, is
that the real multi-skilled developers are often lost in a sea of douchebags,
claiming they know it all.

*** Multi-tier Architecture
- https://en.wikipedia.org/wiki/Multitier_architecture


In software engineering, /multitier architecture/ (often referred to as /n-tier
architecture/) or /multilayered architecture/ is a *client–server architecture
in which presentation, application processing, and data management functions
are physically separated*.  The most widespread use of multitier architecture
is the /three-tier architecture/.

*** What is the 3-Tier Architecture
:PROPERTIES:
:url:      http://www.tonymarston.net/php-mysql/3-tier-architecture.html
:author:   Tony Marston
:date:     October 14, 2012
:END:

**** Introduction to What is the 3-Tier Architecture
This article is in response to [[http://blog.ircmaxell.com/2012/08/n-tier-architecture-introduction.html][N-Tier Architecture - An Introduction]] written by
Anthony Ferrara which I feel gives only a very limited view of what can be a
complex subject.  Different people have different ideas on how an application
can be split into tiers, and different ideas on the benefits which can be
gained from making such a split.  I have been designing and building
multi-tiered applications in different languages for over a decade, so my
exposure to this subject has been quite extensive.  I would like to share with
you my experiences on this subject and hopefully give you a more detailed
picture.

** Git Introduction
*** Setting up Git

Git Objectives and Outcomes

At the end of this lesson you should have set up Git on your computer. At the
end of this lesson, you will be able to:

- Set up a Git repository and perform basic Git operations

- Set up and use online Git repositories

**** Setting up your Development Environment

{{{heading(Software Requirements)}}}

1. Text editor of your choice: Any text editor that you are already familiar
   with can be used for editing the project files.  I will be using Visual
   Studio Code (https://code.visualstudio.com/) as the editor of choice in this
   specialization.  You may also consider other editors such as Brackets
   (http://brackets.io/), Sublime Text (http://www.sublimetext.com/), or Atom
   (https://atom.io/).

2. Browser of your choice: You may use your preferred browser.  I will be using
   Chrome as the browser in all the exercises.  All the exercises and
   assignments in this course have been tested using Chrome v. 46.  Please note
   that not all browsers may support all the HTML5 features to the same extent.
   You might encounter problems when using other browsers.  I strongly urge you
   to use the latest Chrome browser for the exercises and assignments in this
   course so that any problems are minimized.

3. Command line shell: Familiarity with the command-line shell will be
   essential for the exercises.  In Windows a cmd window or power shell with
   admin privileges would be needed.  On a Mac or in Linux, a terminal window
   can be used.  Please get familiar with the "sudo" command in OS X and Linux.

4. Files required for the exercises: We will provide additional starter files
   for the exercises wherever needed.  Links to download the files will be
   provided inline in the exercise instructions that follow each exercise
   video.  Please download the files provided there, if any, before beginning
   the exercise.  The links are also available through the Additional Resources
   of the specific lesson.


*Note*: Please remember to retain the folders and all the files that you create
in the exercises.  Further exercises will build upon the files that you create
in the preceding exercises.  DO NOT DELETE the files at the end of the
exercises, unless otherwise instructed.  You may wish to set up your exercise
folder as a Git repository and commit the files to the repository at the end of
each exercise.  Brief instructions on using Git are available later in this
lesson.

**** Exercise---Video---Setting Up Git
- [[file:resources/week_1/lecture_04/index.mp4]]

**** Exercise---Setting Up Git

{{{heading(Objectives and Outcomes)}}}

In this exercise you will learn to install Git on your computer. Git is
required for using all the remaining Node.js and Node based tools that we
encounter in the rest of the course. At the end of this exercise, you would be
able to:

- Install Git on your computer

- Ensure that Git can be used from the command-line or command-prompt on your
  computer

- Set up some of the basic global configuration for Git


{{{heading(Downloading and Installing Git)}}}

- To install Git on your computer, go to https://git-scm.com/downloads to
  download the Git installer for your specific computing platform.

- Then, follow the installation steps as you install Git using the installer.

- You can find more details about installing Git at
  https://git-scm.com/book/en/v2/Getting-Started-Installing-Git. This document
  lists several ways of installing Git on various platforms.

- Installing some of the GUI tools like GitHub Desktop will also install Git on
  your computer.

- On a Mac, setting up XCode command-line tools also will set up Git on your
  computer.

- You can choose any of the methods that is most convenient for you.


{{{heading(Some Global Configuration for Git)}}}

- Open a cmd window or terminal on your computer.

- Check to make sure that Git is installed and available on the command line,
  by typing the following at the command prompt:
  : git --version

- To configure your user name to be used by Git, type the following at the
  prompt:
  : git config --global user.name "Your Name"

- To configure your email to be used by Git, type the following at the prompt:
  : git config --global user.email <your email address>

- You can check your default Git global configuration, you can type the
  following at the prompt:
  : git config --list

*** Basic Git Commands
- [[file:resources/week_1/lecture_05/index.mp4]]

- [[file:resources/week_1/lecture_05/Git-Exercises.pdf][Git-Exercises.pdf]]


{{{heading(Objectives and Outcomes)}}}

In this exercise you will get familiar with some basic Git commands. At the end
of this exercise you will be able to:

- Set up a folder as a Git repository

- Perform basic Git operations on your Git repository


{{{heading(Basic Git Commands)}}}

- At a convenient location on your computer, create a folder named git-test.

- Open this git-test folder in your favorite editor.

- Add a file named index.html to this folder, and add the following HTML code
  to this file:

  #+name:index.html-skeleton
  #+begin_src html :eval never
    <!DOCTYPE html>
    <html>
        <head></head>

        <body>
            <h1>This is a Header</h1>
        </body>
  #+end_src

{{{subheading(Initializing the folder as a Git repository)}}}

- Go to the git-test folder in your cmd window/terminal and type the following
  at the prompt to initialize the folder as a Git repository:
  : git init


{{{subheading(Checking your Git repository status)}}}

- Type the following at the prompt to check your Git repository's status:
  : git status


{{{subheading(Adding files to the staging area)}}}

- To add files to the staging area of your Git repository, type:
  : git add .


{{{subheading(Commiting to the Git repository)}}}

- To commit the current staging area to your Git repository, type:
  : git commit -m "first commit"


{{{subheading(Checking the log of Git commits)}}}

- To check the log of the commits to your Git repository, type
  : git log --oneline


{{{heading(Modifications)}}}

- Now, modify the ~index.html~ file as follows:

#+name:index.html-modification1
#+begin_src html :eval never
  !DOCTYPE html>
  <html>
      <head></head>

      <body>
          <h1>This is a Header</h1>
          <p>This is a paragraph</p>
      </body>
  </html>
#+end_src

- Add a sub-folder named templates to your git-test folder, and then add a file
  named temp.html to the templates folder. Then set the contents of this file
  to be the same as the index.html file above.

- Then check the status and add all the files to the staging area.

- Then do the second commit to your repository

- Now, modify the index.html file as follows:

#+name:index.html-modification2
#+begin_src html :eval never
  <!DOCTYPE html>
  <html>
      <head></head>

      <body>
          <h1>This is a Header</h1>
          <p>This is a paragraph</p>
          <p>This is a second paragraph</p>
      </body>
  </html>
#+end_src

- Now add the modified ~index.html~ file to the staging area and then do a third
  commit.


{{{subheading(Checking out a file from an earlier commit)}}}

- To check out the index.html from the second commit, find the number of the
  second commit using the git log, and then type the following at the prompt:
  : git checkout <second commit's number> index.html

{{{subheading(Resetting the Git repository)}}}

- To discard the effect of the previous operation and restore index.html to its
  state at the end of the third commit, type:
  : git reset HEAD index.html

- Then type the following at the prompt:
  : git checkout -- index.html

- You can also use ~git reset~ to reset the staging area to the last commit
  without disturbing the working directory.

*** Online Git Repositories
- [[file:resources/week_1/lecture_06/index.mp4]]

- [[file:resources/week_1/lecture_06/Git-Exercises.pdf][Git-Exercises.pdf]]


{{{heading(Objectives and Outcomes)}}}

In this exercise you will learn about how to set up and use an online Git
repository and synchronize your local Git repository with your online
repository. At the end of this exercise, you will be able to:

- Set up the online repository as a remote repository for your local Git
  repository

- Push your commits to the online repository

- Clone an online Git repository to your computer


{{{heading(Setting up an Online Git repository)}}}

- Sign up for an account either at Bitbucket (https://bitbucket.org) or GitHub
  (https://github.com). Note that private repositories on GitHub requires a
  paid account, and is not available for free accounts.

- Then set up an online Git repository named git-test. Note the URL of your
  online Git repository.


{{{heading(Set the local Git repository to set its remote origin)}}}

- At the prompt, type the following to set up your local repository to link to
  your online Git repository:
  : git remote add origin <repository URL>

{{{heading(Pushing your commits to the online repository)}}}

- At the prompt, type the following to push the commits to the online
  repository:
  : git push -u origin master

{{{heading(Cloning an online repository)}}}

- To clone an online repository to your computer, type the following at the
  prompt:
  : git clone <repository URL>

*** Additional Git Resources
- Git site http://git-scm.com.

- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][Installing Git]] chapter from Pro Git

- [[https://git-scm.com/docs][Git reference manual]]

- Quick reference guides:

  - [[https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf][GitHub Cheat Sheet]] (PDF)

  - [[http://ndpsoftware.com/git-cheatsheet.html][Visual Git Cheat Sheet]] (SVG | PNG)

- [[https://www.atlassian.com/git/tutorials/][Atlassian comprehensive Git tutorial]]

** Node.js and NPM

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn the basics of Node.js and NPM. Thereafter, you
will install Node.js and NPM on your machine so that you can start writing
simple Node applications. At the end of this lesson, you should be able to:

- Download and install Node.js and NPM on your machine

- Verify that the installation was successful and your machine is ready for
  using Node.js and NPM.

*** About Node.js and NPM
- [[file:resources/week_1/lecture_07/index.mp4]]

- [[file:resources/week_1/lecture_07/NodeJS-NPM.pdf][NodeJS-NPM.pdf]]

*** Setting Up Node.js and NPM
- [[file:resources/week_1/lecture_08/index.mp4]]


*Note*: Make sure you have installed Git on your machine before you install
Node.js. Please complete the previous Git installation exercise before
proceeding with this exercise.

{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn to set up the Node.js environment, a popular
Javascript based server framework, and node package manager (NPM) on your
machine. To learn more about NodeJS, you can visit https://nodejs.org. For this
course, you need to install Node.js on your machine. At the end of this
exercise, you will be able to:

- Complete the set up of Node.js and NPM on your machine

- Verify that the installation was successful and your machine is ready for
  using Node.js and NPM.


{{{heading(Installing Node)}}}

- To install Node on your machine, go to https://nodejs.org and click on the
  Download button. Depending on your computer's platform (Windows, MacOS or
  Linux), the appropriate installation package is downloaded.

- As an example, on a Mac, you will see the following web page. Click on the
  Download button. Follow along the instructions to install Node on your
  machine. (Note: Now Node gives you the option of installing a mature and
  dependable LTS version and a more newer current version. You can install the
  current version. I will use this version in the course.)


{{{heading(Verifying the Node Installation)}}}

- Open a terminal window on your machine. If you are using a Windows machine,
  open a cmd window or PowerShell window with admin privileges.

- To ensure that your NodeJS setup is working correctly, type the following at
  the command prompt to check for the version of Node and NPM
  : node -v
  : npm -v

*** Additional Resources for Node.js and NPM
- [[https://nodejs.org/][Nodejs.org]]

- [[https://www.npmjs.com/][Npmjs.com]]

- [[https://nodejs.org/api/][Node API Documentation]]

- [[https://docs.npmjs.com/][NPM Documentation]]

** Node Modules

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn to write Node applications. You will learn about
Node modules and how you can make use of them within your Node applications. At
the end of this lesson, you will be able to:

- Write simple Node applications and run them using Node

- Develop Node modules and use them within your Node applications

- Learn about using callbacks and handling errors within your Node application

*** Understanding Node Modules
- [[file:resources/week_1/lecture_09/index.mp4]]

- [[file:resources/week_1/lecture_09/Node-Modules.pdf][Node-Modules.pdf]]

**** Exercise in Understanding Node Modules
- [[file:resources/week_1/lecture_10/index.mp4]]


{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn about writing Node applications using
JavaScript and also learn about the basics of Node modules. At the end of this
exercise, you will be able to:

- Write a simple Node application in JavaScript.

- Understand the basics of Node modules and write simple file-based Node
  modules


{{{heading(Starting a Node Application)}}}

- Go to a convenient location on your computer and create a folder named
  NodeJS. Then move to this folder.

- Now create a folder named node-examples and then move into this folder.

- At the prompt, type the following to initialize a package.json file in the
  node-examples folder:
  : npm init

- Accept the standard defaults suggested and then update the package.json file
  until you end up with the file containing the following:

  #+name:default-package.json
  #+begin_src js :eval never
    {
      "name": "node-examples",
      "version": "1.0.0",
      "description": "Simple Node Examples",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "node index"
      },
      "author": "Jogesh Muppala",
      "license": "ISC"
    }
  #+end_src

- Create a file named ~index.js~ and add the following code to this file:

  #+name:basic-index.js
  #+begin_src js :eval never
    var rect = {
            perimeter: (x, y) => (2*(x+y)),
            area: (x, y) => (x*y)
    };

    function solveRect(l,b) {
        console.log("Solving for rectangle with l = " + l + " and b = " + b);

        if (l <= 0 || b <= 0) {
            console.log("Rectangle dimensions should be greater than zero:  l = "
                   + l + ",  and b = " + b);
        }
        else {
                console.log("The area of the rectangle is " + rect.area(l,b));
                console.log("The perimeter of the rectangle is " + rect.perimeter(l,b));
        }
    }

    solveRect(2,4);
    solveRect(3,5);
    solveRect(0,5);
    solveRect(-3,5);
  #+end_src

- To run the Node application, type the following at the prompt:
  : npm start

- To initialize a Git repository and add the current files in the folder to the
  repository, type the following at the prompt:
  : git init
  : git add .

- Then, do a Git commit with the message "Simple Node Example".


{{{heading(A Simple Node Module)}}}

- Now, create a file named ~rectangle.js~, and add the following code to it:

  #+name:rectangle.js
  #+begin_src js :eval never
    exports.perimeter =  (x, y) => (2*(x+y));

    exports.area = (x, y) => (x*y);
  #+end_src

- Then, update ~index.js~ as follows (place the following at the top if the
  file):
  : var rect = require('./rectangle');

- Run the Node application like before and observe that the result will be the
  same.

- Do a Git commit with the message "Simple Node Module".

*** Node Modules and Callbacks and Error Handling
- [[file:resources/week_1/lecture_11/index.mp4]]

- [[file:resources/week_1/lecture_11/Node-Callbacks-Error_Handling.pdf][Node-Callbacks-Error_Handling.pdf]]

- [[file:resources/week_1/lecture_12/index.mp4]]


{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn about callbacks, JavaScript closures and error
handling in Node applications. At the end of this exercise, you will be able
to:

- Using Callbacks in Node applications

- Error handling in Node applications


{{{heading(Using Callbacks and Error Handling)}}}

- Update ~rectangle.js~ as shown below:

  #+name:rectangle.js-updated
  #+begin_src js :eval never
    module.exports = (x,y,callback) => {
        if (x <= 0 || y <= 0)
            setTimeout(() => 
                callback(new Error("Rectangle dimensions should be greater than zero: l = "
                    + x + ", and b = " + y), 
                null),
                2000);
        else
            setTimeout(() => 
                callback(null, {
                    perimeter: () => (2*(x+y)),
                    area:() => (x*y)
                }), 
                2000);
    }
  #+end_src

- Then, update ~index.js~ as shown below:

  #+name:index.js-updated
  #+begin_src js :eval never
    function solveRect(l,b) {
        console.log("Solving for rectangle with l = "
                    + l + " and b = " + b);
        rect(l,b, (err,rectangle) => {
            if (err) {
                    console.log("ERROR: ", err.message);
                }
            else {
                console.log("The area of the rectangle of dimensions l = "
                    + l + " and b = " + b + " is " + rectangle.area());
                console.log("The perimeter of the rectangle of dimensions l = "
                    + l + " and b = " + b + " is " + rectangle.perimeter());
            }
        });
        console.log("This statement after the call to rect()");
    };
  #+end_src

- Run the Node application as before and see the result.

Do a Git commit with the message "Node Callbacks and Error Handling".

*** Node Modules Additional Resources

- [[https://nodejs.org/api/modules.html][Node Modules]]

- [[https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/][The Node.js Event Loop, Timers, and process.nextTick()]]

- [[http://www.commonjs.org/][CommonJS]]

- [[http://wiki.commonjs.org/wiki/Modules/1.1.1][CommonJS Module Format]]

- [[http://requirejs.org/][RequireJS]]

** HTTP Node Module

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn more about the Node HTTP core module.  You will
create a simple HTTP server using the Node HTTP module and serve HTML files
from a public folder.  Along the way you will learn about the fs and path Node
core modules.  At the end of this lesson, you will be able to:

- Create a simple HTTP server using the Node HTTP core module

- Create a web server to serve static HTML files from a folder

*** Introduction to Networking Essentials

- [[file:resources/week_1/lecture_13/index.mp4]]

- [[file:resources/week_1/lecture_13/Networking-Essentials.pdf][Networking-Essentials.pdf]]

*** Introduction to the HTTP Module

- [[file:resources/week_1/lecture_14/index.mp4]]

- [[file:resources/week_1/lecture_14/Node-HTTP.pdf][Node-HTTP.pdf]]

*** Exercise---Node and the HTTP Module

- [[file:resources/week_1/lecture_15/index.mp4]]

{{{heading(Objectives and Outcomes)}}}

In this exercise, you will explore three core Node modules: ~http~, ~fs~ and
~path~.  At the end of this exercise, you will be able to:

- Implement a simple HTTP Server

- Implement a server that returns html files from a folder

**** A Simple HTTP Server

From within the Org buffer, create this project by issuing the following commands
commands:

1. =C-c C-v b= to execute the bash scripts to initialize the Node project
2. =C-c C-v t= to tangle the ~index.js~ file into the project directory
3. =cd node-http= to move into the project directory
4. =yarn start=  to start the ~http~ server
5. =open localhost:3000= to open a browser and hit the server

- Create a folder named ~node-http~ in the NodeJS folder and move into the
  folder.

- In the ~node-http~ folder, create a subfolder named ~public~.

- At the prompt, type the following to initialize a ~package.json~ file in the
  ~node-examples~ folder.

  #+name:http-server-create-public-subfolder
  #+begin_src sh :results silent :eval never-export
    mkdir -p node-http/public && cd node-http && npm init -y
  #+end_src

- Accept the standard defaults suggested, and add a =scripts.start = node index"
  until you end up with a ~package.json~ file containing the following:

  #+begin_src js :eval never
    {
      "name": "node-http",
      "version": "1.0.0",
      "description": "Node HTTP Module Example",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "node index"
      },
      "author": "Jogesh Muppala",
      "license": "ISC"
    }
  #+end_src

  #+name:http-server-package.json-start-script
  #+begin_src js :results output :eval never-export
    const fs = require('fs');
    let package = JSON.parse(fs.readFileSync("./node-http/package.json", "utf-8"));
    package.scripts.start = "node index";
    fs.writeFileSync('./node-http/package.json', JSON.stringify(package, null, 2));
    console.log(JSON.stringify(package, null, 2));
  #+end_src

  #+RESULTS: http-server-package.json-start-script
  #+begin_example
  {
    "name": "node-http",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "test": "echo \"Error: no test specified\" && exit 1",
      "start": "node index"
    },
    "keywords": [],
    "author": "",
    "license": "ISC"
  }
  #+end_example

- Create a file named ~index.js~ and add the following code to it:

  #+name:http-server-index.js
  #+begin_src js :eval never :tangle node-http/index.js :results silent
    const http = require('http');

    const hostname = 'localhost';
    const port = 3000;

    const server = http.createServer((req, res) => {
        console.log(req.headers);
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/html');
        res.end('<html><body><h1>Hello, World!</h1></body></html>');
    })

    server.listen(port, hostname, () => {
      console.log(`Server running at http://${hostname}:${port}/`);
    });
  #+end_src

- Start the server by typing the following at the prompt:

  : npm start

- Then you can type:

  :  http://localhost:3000

  {{{noindent}}}in your browser address bar and see the result.

- You can also use [[http://www.getpostman.com/][postman]] chrome extension to send requests to the server and
  see the response.  Alternately, you can download the stand-alone Postman tool
  from http://getpostman.com and install it on your computer.

- Initialize a Git repository, check in the files and do a Git commit with the
  message "Node HTTP Example 1".

**** Serving HTML Files

- In the ~public~ folder, create a file named ~index.html~ and add the
  following code to it:

  #+begin_src html :eval never
    <html>
      <title>This is aboutus.html</title>
      <body>
        <h1>Aboutus.html</h1>
        <p>This is the contents of the aboutus.html file</p>
      </body>
    </html>
  #+end_src

- Then update ~index.js~ as follows:

  #+begin_src js :eval never
    ...
    const fs = require('fs');
    const path = require('path');
    ...

    const server = http.createServer((req, res) => {
      console.log('Request for ' + req.url + ' by method ' + req.method);

      if (req.method == 'GET') {
        var fileUrl;
        if (req.url == '/') fileUrl = '/index.html';
        else fileUrl = req.url;

        var filePath = path.resolve('./public'+fileUrl);
        const fileExt = path.extname(filePath);
        if (fileExt == '.html') {
          fs.exists(filePath, (exists) => {
            if (!exists) {
              res.statusCode = 404;
              res.setHeader('Content-Type', 'text/html');
              res.end('<html><body><h1>Error 404: ' + fileUrl + 
                          ' not found</h1></body></html>');
              return;
            }
            res.statusCode = 200;
            res.setHeader('Content-Type', 'text/html');
            fs.createReadStream(filePath).pipe(res);
          });
        }
        else {
          res.statusCode = 404;
          res.setHeader('Content-Type', 'text/html');
          res.end('<html><body><h1>Error 404: ' + fileUrl + 
                  ' not a HTML file</h1></body></html>');
        }
      }
      else {
          res.statusCode = 404;
          res.setHeader('Content-Type', 'text/html');
          res.end('<html><body><h1>Error 404: ' + req.method + 
                  ' not supported</h1></body></html>');
      }
    })

    ...
  #+end_src

  #+RESULTS:

- Start the server, and send various requests to it and see the corresponding
  responses.

- Do a Git commit with the message "Node HTTP Example 2".

*** Node and HTTP Additional Resources

- [[https://nodejs.org/api/http.html][Node HTTP]]

- [[https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/][Anatomy of an HTTP Transaction]]

- [[https://nodejs.org/api/fs.html][fs Module]]

- [[https://nodejs.org/api/path.html][path Module]]

- [[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol][Hypertext Transfer Protocol]]

- [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes][List of HTTP Status Codes]]

- [[http://getpostman.com/][Postman]]

*** Guide---Anatomy of an HTTP Transaction
:PROPERTIES:
:url:      https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/
:header-args: :eval no
:END:

{{{heading(The Purpose of this Guide)}}}

#+cindex:node http handling
The purpose of this guide is to impart a solid understanding of the process of
Node.js HTTP handling.

{{{heading(Prerequisites)}}}

#+cindex:http requests
#+cindex:EventEmitters
#+cindex:Streams
We'll assume that you know, in a general sense, how HTTP requests work,
regardless of language or programming environment.  We'll also assume a bit of
familiarity with Node.js EventEmitters and Streams.

**** Create the Server
#+cindex:@code{createServer}
#+cindex:web server object
#+cindex:server object
Any node web server application will at some point have to create a web server
object.  This is done by using ~createServer~.

#+begin_src js
  const http = require('http');

  const server = http.createServer((request, response) => {
    // magic happens here!
  });
#+end_src

{{{subheading(Request Handler)}}}

#+cindex:request handler
The function that's passed in to ~createServer~ is called once for every HTTP
request that's made against that server, so it's called the /request handler/.

{{{subheading(Server Object)}}}

#+cindex:EventEmitter, server object
#+cindex:server object as event emitter
#+cindex:listener object
In fact, the =Server= object returned by ~createServer~ is an =EventEmitter=,
and what we have here is just shorthand for creating a =server= object and then
adding the =listener= later.

{{{subheading(Adding a Listener Explicitly)}}}

#+begin_src js
  const server = http.createServer();
  server.on('request', (request, response) => {
    // the same kind of magic happens here!
  });
#+end_src

{{{subheading(HTTP Requests and the =request= and =response= Objects)}}}

When an HTTP request hits the server, node calls the request handler function
with a few handy objects for dealing with the transaction, =request= and
=response=.  We'll get to those shortly.

{{{subheading(The Listen Method)}}}

#+cindex:@code{listen} method
#+cindex:port number
In order to actually serve requests, the ~listen~ method needs to be called on
the =server= object.  In most cases, all you'll need to pass to ~listen~ is the
port number you want the server to listen on.  There are some other options
too, so consult the [[https://nodejs.org/api/http.html][API reference]].

**** Method-URL-Headers

{{{heading(Looking at the Request Objects’s Method and URL Properties)}}}

#+cindex:request object
#+cindex:properties, request object
#+cindex:request method, url
#+cindex:method, request property
#+cindex:url, request property
When handling a request, the first thing you'll probably want to do is look at
the method and URL, so that appropriate actions can be taken.  Node makes this
relatively painless by putting handy properties onto the =request=
object.[fn:1]

: const { method, url } = request;

The method here will always be a normal HTTP method/verb.  The url is the full
URL without the server, protocol or port.  For a typical URL, this means
everything after and including the third forward slash.

{{{heading(Looking at the Request Headers)}}}

#+cindex:headers
Headers are also not far away.  They're in their own object on =request= called
=headers=.

#+begin_src js
  const { headers } = request;
  const userAgent = headers['user-agent'];
#+end_src

It's important to note here that all headers are represented in lower-case
only, regardless of how the client actually sent them.  This simplifies the
task of parsing headers for whatever purpose.

{{{subheading(Raw Headers)}}}

#+cindex:raw headers
If some headers are repeated, then their values are overwritten or joined
together as comma-separated strings, depending on the header.  In some cases,
this can be problematic, so =rawHeaders= is also available.

**** Request Body

#+cindex:request body data
#+cindex:body data
#+cindex:data, request
When receiving a =POST= or =PUT= request, the =request= body might be important
to your application.  Getting at the =body= data is a little more involved than
accessing =request= headers.

{{{heading(The Body is a Readable Stream Object)}}}

#+cindex:ReadableStream interface
The =request= object that's passed in to a handler implements the
=ReadableStream= interface.  This stream can be listened to or piped elsewhere
just like any other stream.

{{{subheading(Data and End Events)}}}

#+cindex:@code{data} event
#+cindex:@code{end} event
#+cindex:events, ReadableStream
We can grab the data right out of the stream by listening to the stream's
'data' and 'end' events.

{{{subheading(Data Buffers)}}}

#+cindex:@code{Buffer} object
The chunk emitted in each 'data' event is a =Buffer=.  If you know it's going
to be string data, the best thing to do is collect the data in an array, then
at the 'end', concatenate and stringify it.[fn:2]

#+begin_src js
  let body = [];
  request.on('data', (chunk) => {
    body.push(chunk);
  }).on('end', () => {
    body = Buffer.concat(body).toString();
    // at this point, `body` has the entire request body stored in it as a string
  });
#+end_src

**** About Errors
#+cindex:errors, EventEmitter
#+cindex:EventEmitter errors
Since the request object is a =ReadableStream=, it's also an =EventEmitter= and
behaves like one when an error happens.

{{{heading(Add an Error Listener)}}}

#+cindex:@code{error} event
#+cindex:listener, @code{error} event
#+cindex:error listener
An error in the request stream presents itself by emitting an 'error' event on
the stream.  If you don't have a listener for that event, the error will be
thrown, which could crash your Node.js program.  You should therefore add an
'error' listener on your request streams, even if you just log it and continue
on your way.  (Though it's probably best to send some kind of HTTP error
response.  More on that later.)

#+begin_src js
  request.on('error', (err) => {
    // This prints the error message and stack trace to `stderr`.
    console.error(err.stack);
  });
#+end_src

There are [[https://nodejs.org/api/errors.html][other ways of handling these errors]] such as other abstractions and
tools, but always be aware that errors can and do happen, and you're going to
have to deal with them.

**** So Far

At this point, we've covered:

- creating a server; and
- grabbing the:
  - method
  - URL
  - headers
  - body
- out of the requests


When we put that all together, it might look something like this:

#+caption:Sample of a Simple HTTP Server Looking at Requests
#+name:simple-http-server-looking-at-requests
#+begin_src js -n
  const http = require('http');

  http.createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request.on('error', (err) => {
      console.error(err);
    }).on('data', (chunk) => {
      body.push(chunk);
    }).on('end', () => {
      body = Buffer.concat(body).toString();
      // At this point, we have the headers, method, url and body, and can now
      // do whatever we need to in order to respond to this request.
    });
  }).listen(8080); // Activates this server, listening on port 8080.
#+end_src

If we run this example, we'll be able to receive requests, but not respond to
them.  In fact, if you hit this example in a web browser, your request would
time out, as nothing is being sent back to the client.

#+cindex:ServerResponse object, response
#+cindex:WritableStream object, response
So far we haven't touched on the =response= object at all, which is an instance
of =ServerResponse=, which is a =WritableStream=.  It contains many useful
methods for sending data back to the client.  We'll cover that next.

**** HTTP Status Codes

{{{heading(Setting the Status Code Property)}}}

#+cindex:http status code
#+cindex:status code, http
#+cindex:@code{statusCode} property
If you don't bother setting it, the HTTP status code on a response will always
be 200.  Of course, not every HTTP response warrants this, and at some point
you'll definitely want to send a different status code.  To do that, you can
set the =statusCode= property.

: response.statusCode = 404; // Tell the client that the resource wasn't found.

There are some other shortcuts to this, as we'll see soon.

**** Setting Response Headers

{{{heading(Setting Response Headers with setHeader Method)}}}

#+cindex:@code{setHeader} method
#+cindex:response headers
#+cindex:headers, response
Headers are set through a convenient method called ~setHeader~.

#+begin_src js
  response.setHeader('Content-Type', 'application/json');
  response.setHeader('X-Powered-By', 'bacon');
#+end_src

When setting the headers on a response, the case is insensitive on their names.
If you set a header repeatedly, the last value you set is the value that gets
sent.

**** Explicitly Sending Header Data

#+cindex:implicit headers
The methods of setting the headers and status code that we've already discussed
assume that you're using "implicit headers".  This means you're counting on
node to send the headers for you at the correct time before you start sending
body data.

{{{Writing Headers Using writeHead Method}}}

#+cindex:@code{writeHead} method
#+cindex:explicit headers
If you want, you can explicitly write the headers to the response stream.  To
do this, there's a method called ~writeHead~, which writes the status code and
the headers to the stream.

#+begin_src js
  response.writeHead(200, {
    'Content-Type': 'application/json',
    'X-Powered-By': 'bacon'
  });
#+end_src

Once you've set the headers (either implicitly or explicitly), you're ready to
start sending response data.

**** Sending Response Body

{{{heading(Writing to the Response Body using Write Stream Methods)}}}

#+cindex:response object
#+cindex:WritableStream, response object
#+cindex:@code{write} method
#+cindex:data, response
#+cindex:response data
Since the response object is a =WritableStream=, writing a response body out to
the client is just a matter of using the usual stream methods.

#+begin_src js
  response.write('<html>');
  response.write('<body>');
  response.write('<h1>Hello, World!</h1>');
  response.write('</body>');
  response.write('</html>');
  response.end();
#+end_src

{{{subheading(Using the end Method)}}}

#+cindex:@code{end} method
The ~end~ function on streams can also take in some optional data to send as
the last bit of data on the stream, so we can simplify the example above as
follows:[fn:3]

: response.end('<html><body><h1>Hello, World!</h1></body></html>');

**** About Response Errors

#+cindex:error events, response object
The =response= stream can also emit 'error' events, and at some point you're
going to have to deal with that as well.  All of the advice for request stream
errors still applies here.

**** Put It All Together

#+cindex:JSON data
Now that we've learned about making HTTP responses, let's put it all together.
Building on the earlier example, we're going to make a server that sends back
all of the data that was sent to us by the user.  We'll format that data as
JSON using ~JSON.stringify~.

#+caption:Example of a Complete Node HTTP Server
#+name:simple-node-http-server
#+begin_src js -n
  const http = require('http');

  http.createServer((request, response) => {
    const { headers, method, url } = request;
    let body = [];
    request.on('error', (err) => {
      console.error(err);
    }).on('data', (chunk) => {
      body.push(chunk);
    }).on('end', () => {
      body = Buffer.concat(body).toString();
      // BEGINNING OF NEW STUFF

      response.on('error', (err) => {
        console.error(err);
      });

      response.statusCode = 200;
      response.setHeader('Content-Type', 'application/json');
      // Note: the 2 lines above could be replaced with this next one:
      // response.writeHead(200, {'Content-Type': 'application/json'})

      const responseBody = { headers, method, url, body };

      response.write(JSON.stringify(responseBody));
      response.end();
      // Note: the 2 lines above could be replaced with this next one:
      // response.end(JSON.stringify(responseBody))

      // END OF NEW STUFF
    });
  }).listen(8080);
#+end_src

**** Echo Server Example

#+cindex:echo server example
#+cindex:example of echo server
Let's simplify the previous example to make a simple echo server, which just
sends whatever data is received in the request right back in the response.  All
we need to do is grab the data from the request stream and write that data to
the response stream, similar to what we did previously.

#+begin_src js
  const http = require('http');

  http.createServer((request, response) => {
    let body = [];
    request.on('data', (chunk) => {
      body.push(chunk);
    }).on('end', () => {
      body = Buffer.concat(body).toString();
      response.end(body);
    });
  }).listen(8080);
#+end_src

Now let's tweak this.  We want to only send an echo under the following
conditions:

- The request method is =POST=.

- The URL is ~/echo~.

- In any other case, we want to simply respond with a 404.


#+begin_src js
  const http = require('http');

  http.createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      let body = [];
      request.on('data', (chunk) => {
        body.push(chunk);
      }).on('end', () => {
        body = Buffer.concat(body).toString();
        response.end(body);
      });
    } else {
      response.statusCode = 404;
      response.end();
    }
  }).listen(8080);
#+end_src

{{{heading(Performing Routing)}}}

#+cindex:routing
#+cindex:express module
#+cindex:router module
*Note*: By checking the URL in this way, we're doing a form of "routing".
Other forms of routing can be as simple as switch statements or as complex as
whole frameworks like =express=.  If you're looking for something that does
routing and nothing else, try =router=.

{{{heading(Simplified Echo Server using pipe Method}}}

#+cindex:@code{pipe} method
Great! Now let's take a stab at simplifying this.  Remember, the =request=
object is a =ReadableStream= and the =response= object is a =WritableStream=.
That means we can use ~pipe~ to direct data from one to the other.  That's
exactly what we want for an echo server!

#+begin_src js
  const http = require('http');

  http.createServer((request, response) => {
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  }).listen(8080);
#+end_src

{{{heading(Dealing with Errors)}}}

We're not quite done yet though.  As mentioned multiple times in this guide,
errors can and do happen, and we need to deal with them.

#+cindex:error handling, echo server
#+cindex:@code{stderr}
To handle errors on the =request= stream, we'll log the error to =stderr= and
send a 400 status code to indicate a Bad Request.  In a real-world application,
though, we'd want to inspect the error to figure out what the correct status
code and message would be.  As usual with errors, you should consult the Error
documentation.

On the response, we'll just log the error to =stderr=.

#+caption:Complete Node HTTP Echo Server with Error Handling
#+name:node-http-echo-server-with-error-handling
#+begin_src js -n
  const http = require('http');

  http.createServer((request, response) => {
    request.on('error', (err) => {
      console.error(err);
      response.statusCode = 400;
      response.end();
    });
    response.on('error', (err) => {
      console.error(err);
    });
    if (request.method === 'POST' && request.url === '/echo') {
      request.pipe(response);
    } else {
      response.statusCode = 404;
      response.end();
    }
  }).listen(8080);
#+end_src

**** Summary of Node HTTP Module
We've now covered most of the basics of handling HTTP requests.  At this point,
you should be able to:

- Instantiate an HTTP server with a request handler function, and have it
  listen on a port.

- Get headers, URL, method and body data from request objects.

- Make routing decisions based on URL and/or other data in request objects.

- Send headers, HTTP status codes and body data via response objects.

- Pipe data from request objects and to response objects.

- Handle stream errors in both the request and response streams.


From these basics, Node.js HTTP servers for many typical use cases can be
constructed.  There are plenty of other things these APIs provide, so be sure
to read through the API docs for =EventEmitters=, =Streams=, and =HTTP=.

** Express Web Framework

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn about the Express framework that enables
implementing and deploying powerful web servers based on Node.  At the end of
this lesson, you will be able to:

- Implement a web server using the Express framework

- Develop a web server that supports a REST API

- Use Express router to implement support for the REST API

*** Introduction to Express Video
- [[file:resources/week_1/lecture_16/index.mp4]]

- [[file:resources/week_1/lecture_16/Intro-Express.pdf][Intro-Express.pdf]]

*** Exercise---Introduction to Express

- [[file:resources/week_1/lecture_17/index.mp4]]

{{{heading(Objectives)}}}

In this exercise, you will make use of the Express framework to implement
similar functionality as implemented by the HTTP module based servers in the
previous exercise.  At the end of this exercise, you will be able to:

- Implement a simple web server using Express framework

- Implement a web server that serves static content

**** Implement a Simple Web Server Using Express

- Create a folder named ~node-express~ in the NodeJS folder and move to that
  folder.

  : mkdir node-express

- Copy the ~public~ folder from ~node-http~ to this folder.

  : cp node-http/public node-express/public

- At the prompt, type the following to initialize a ~package.json~ file in the
  ~node-express~ folder:

  : npm init

- Accept the standard defaults suggested until you end up with a ~package.json~
  file containing the following:

  #+caption:Node Express Package Manifest
  #+name:node-express/package.json
  #+BEGIN_SRC js
    {
      "name": "node-express",
      "version": "1.0.0",
      "description": "Node Express Examples",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "node index"
      },
      "author": "Jogesh Muppala",
      "license": "ISC"
    }
  #+END_SRC

- Then, install the Express framework in the folder by typing the following at
  the prompt:

  : npm install express@4.16.3 --save

- Create a file named ~.gitignore~ and add the following to it:

  : node_modules

- Create a file named ~index.js~ and add the following code to it:

  #+caption: Node Express Index.js File
  #+name:node-express-index.js
  #+BEGIN_SRC js
    const express = require('express'),
         http = require('http');

    const hostname = 'localhost';
    const port = 3000;

    const app = express();

    app.use((req, res, next) => {
      console.log(req.headers);
      res.statusCode = 200;
      res.setHeader('Content-Type', 'text/html');
      res.end('<html><body><h1>This is an Express Server</h1></body></html>');

    });

    const server = http.createServer(app);

    server.listen(port, hostname, () => {
      console.log(`Server running at http://${hostname}:${port}/`);
    });
  #+END_SRC

- Start the server by typing the following at the prompt, and then interact
  with the server:

  : npm start

- Initialize a Git repository, add the files and do a Git commit with the
  message "Express Example".

**** Implement a Web Server Serving Static Content

- Install ~morgan~ by typing the following at the prompt.  Morgan is used for
  logging purposes:

  : npm install morgan@1.9.0 --save

- Update ~index.js~ as follows:

  #+BEGIN_SRC js
    . . .

    const morgan = require('morgan');

    . . .

    app.use(morgan('dev'));

    app.use(express.static(__dirname + '/public'));

    . . .
  #+END_SRC

- Start the server and interact with it and observe the behavior.

- Do a Git commit with the message "Express Serve Static Files".

*** Brief Representational State Transfer---REST

- [[file:resources/week_1/lecture_18/index.mp4]]

- [[file:resources/week_1/lecture_18/REST.pdf][REST.pdf]]

*** Express Router

- [[file:resources/week_1/lecture_19/index.mp4]]

- [[file:resources/week_1/lecture_19/Express-Router.pdf][Express-Router.pdf]]

*** Exercice---Express Router

- [[file:resources/week_1/lecture_20/index.mp4]]

*** Express Additional Resources

- [[http://expressjs.com/][ExpressJS]]

- [[https://github.com/senchalabs/connect][Connect]]

- [[https://github.com/expressjs/express/wiki][Express Wiki]]

- [[https://github.com/expressjs/morgan][morgan]]

- [[https://github.com/expressjs/body-parser][body-parser]]

- [[http://evanhahn.com/understanding-express/][Understanding Express.js]]

- [[https://stephensugden.com/middleware_guide/][A Short Guide to Connect Middleware]]

*** Article---Understanding Express.js
:PROPERTIES:
:url:      http://evanhahn.com/understanding-express/
:author:   Evan Hahn
:date:     March 5, 2014
:END:

This is aimed at people who have some familiarity with Node.js.  They know how
to run Node scripts and can install packages with npm.  You don't have to be an
expert, though.  This guide was last updated for Express 4.16.4. It's an
introduction and mostly deals with concepts.

Express.js describes itself better than I can: “a minimal and flexible node.js
web application framework". It helps you build web apps.  If you've used Sinatra
or Flask in other languages, a lot of this will be familiar.”

Like any abstraction, Express hides difficult bits and says "don't worry, you
don't need to understand this part".  It does things for you so that you don't
have to bother.  In other words, it's magic.

It's good magic, too. Famous companies like PayPal, Netflix, Airtable, and
MySpace use it.  But lots of people use it for building...well, almost
anything!

But all magic comes at a price: you might not understand the inner workings of
Express.  This is like driving a car; I drive a car just fine without intimate
knowledge of its workings, but I'd be better off with that knowledge.  What if
things break?  What if you want to get all the performance you can out of the
car?  What if you have an insatiable thirst for knowledge?

So let's understand Express from the bottom, with Node.

**** Bottom Layer---Node’s HTTP Server
** Assignment 1---Node Modules Express and REST API
In this assignment you will continue the exploration of Node modules, Express
and the REST API.  You will design two new express routers to support REST API
end points for promotions and leadership.

{{{heading(Step-By-Step Assignment Instructions)}}}

{{{subheading(Assignment Overview)}}}

At the end of this assignment, you should have completed the following tasks to
update the server:

- Created a Node module using Express router to support the routes for the
  dishes REST API.

- Created a Node module using Express router to support the routes for the
  promotions REST API.

- Created a Node module using Express router to support the routes for the
  leaders REST API.


{{{subheading(Assignment Requirements)}}}

The REST API for our Angular and Ionic/Cordova application that we built in the
previous courses requires us to support the following REST API end points:

1. http://localhost:3000/dishes/:dishId

2. http://localhost:3000/promotions and http://localhost:3000/promotions/:promoId

3. http://localhost:3000/leaders and http://localhost:3000/leaders/:leaderId


We need to support =GET=, =PUT=, =POST= and =DELETE= operations on each of the
endpoints mentioned above, including supporting the use of route parameters to
identify a specific promotion and leader.  We have already constructed the REST
API for the ~dishes~ route in the previous exercise.

This assignment requires you to complete the following three tasks. Detailed
instructions for each task are given below.


{{{subheading(Task 1)}}}

In this task you will create a separate Node module implementing an Express
router to support the REST API for the dishes.  You can reuse all the code that
you implemented in the previous exercise.  To do this, you need to complete the
following:

- Update the Node module named ~dishRouter.js~ to implements the Express router
  for the ~/dishes/:dishId~ REST API end point.


{{{subheading(Task 2)}}}

In this task you will create a separate Node module implementing an Express
router to support the REST API for the promotions.  To do this, you need to
complete the following:

- Create a Node module named ~promoRouter.js~ that implements the Express
  router for the ~/promotions~ and ~/promotions/:promoId~ REST API end points.

- Require the Node module you create above within your Express application and
  mount it on the ~/promotions~ route.


{{{subheading(Task 3)}}}

In this task you will create a separate Node module implementing an Express
router to support the REST API for the leaders.  To do this, you need to
complete the following:

- Create a Node module named ~leaderRouter.js~ that implements the Express
  router for the ~/leaders~ and ~/leaders/:leaderId~ REST API end points.

- Require the Node module you create above within your Express application and
  mount it on the ~/leaders~ route.


{{{heading(Review Criterial)}}}

Upon completion of the assignment, your submission will be reviewed based on
the following criteria:

{{{subheading(Task 1)}}}

- The REST API supports GET, PUT, POST and DELETE operations on /dishes/:dishId
  end point.


{{{subheading(Task 2)}}}

- The new Node module, promoRouter is implemented and used within your server
  to support the /promotions end point.

- The REST API supports =GET=, =PUT=, =POST= and =DELETE= operations on
  ~/promotions~ and =GET=, =PUT=, =POST= and =DELETE= operations on
  ~/promotions/:promoId~ end points.


{{{subheading(Task 3)}}}

- The new Node module, leaderRouter is implemented and used within your server
  to support the /leaders end point.

- The REST API supports =GET, =PUT=, =POST= and =DELETE= operations on
  ~/leadership~ and =GET=, =PUT=, =POST= and DELETE= operations on
  ~/leaders/:leaderId~ end points.
* Week 2---Persistent Storage with MongoDB
:PROPERTIES:
:length:   9h 12m
:END:

* Week 3---Security and Authentication
:PROPERTIES:
:length:   9h 26m
:END:

* Week 4---Backend as a Service BaaS
:PROPERTIES:
:length:   18h 8m
:END:

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright {{{noindent}}}\copy 2019 {{{author}}} {{{version}}}

* Tables
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Table

* Listings
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo: @listoffloats Listing

* Programs
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Functions
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Definitions                                                      :noexport:
#+macro:heading @@html:<h2>@@@@texinfo:@heading@@ $1@@html:</h2>@@
#+macro:subheading @@html:<h3>@@@@texinfo:@heading@@ $1@@html:</h3>@@
#+macro:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro:noindent @@texinfo:@noindent @@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
#+macro:command @@texinfo:@command{@@$1@@texinfo:}@@
#+macro:option @@texinfo:@option{@@$1@@texinfo:}@@
#+macro:file @@texinfo:@file{@@$1@@texinfo:}@@

* Options                                                          :noexport:
#+options: H:4 ':t

* Local Variables                                                  :noexport:

* Footnotes

[fn:1]Note: The request object is an instance of IncomingMessage.

[fn:2]Note: This may seem a tad tedious, and in many cases, it is. Luckily,
there are modules like concat-stream and body on npm which can help hide away
some of this logic. It's important to have a good understanding of what's going
on before going down that road, and that's why you're here!

[fn:3]Note: It's important to set the status and headers before you start
writing chunks of data to the body. This makes sense, since headers come before
the body in HTTP responses.
# Local Variables:
# fill-column: 79
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (org-indent-mode)
# eval: (electric-quote-local-mode)
# End:
