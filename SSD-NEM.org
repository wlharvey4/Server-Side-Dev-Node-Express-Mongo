# -*- mode:org; -*-

#+title:Server-Side Development with NodeJS, Express, and MongoDB
#+author:The Hong Kong University of Science and Technology
#+date:2019-12-11 16:40
#+subtitle: {{{version}}} {{{date}}}
#+macro:version Version 0.0.10

#+texinfo: @insertcopying

* About the Course
:PROPERTIES:
:unnumbered: t
:END:

This course deals with all things server-side.  We base the entire course
around the NodeJS platform.  We start with a brief overview of the Web
protocols: HTTP and HTTPS.  We examine NodeJS and NodeJS modules: Express for
building web servers.  On the database side, we review basic CRUD operations,
NoSQL databases, in particular MongoDB and Mongoose for accessing MongoDB from
NodeJS.  We examine the REST concepts and building a RESTful API.  We touch
upon authentication and security. Finally we review backend as a service (BaaS)
approaches, including mobile BaaS, both open-source and commercial BaaS
services.

At the end of this course, you will be able to:

- Demonstrate an understanding of server-side concepts, CRUD and REST

- Build and configure a backend server using NodeJS framework

- Build a RESTful API for the front-end to access backend services


{{{heading(This course is part of multiple programs)}}}

This course can be applied to multiple Specializations or Professional
Certificates programs.  Completing this course will count towards your learning
in any of the following programs:

- [[https://www.coursera.org/specializations/full-stack-react][Full-Stack Web Development with React Specialization]]

- [[https://www.coursera.org/specializations/full-stack-mobile-app-development][Full Stack Web and Multiplatform Mobile App Development Specialization]]

** Welcome from the Instructor
:PROPERTIES:
:instructor: Jogesh K. Muppala
:unnumbered: t
:END:

Welcome to Server-side Development with NodeJS, Express and MongoDB!  You’re
joining thousands of learners currently enrolled in the course.  I'm excited to
have you in the class and look forward to your contributions to the learning
community.

To begin, I recommend taking a few minutes to explore the course site.  Review
the material we’ll cover each week, and preview the assignments you’ll need to
complete to pass the course.  Click Discussions to see forums where you can
discuss the course material with fellow students taking the class.

If you have questions about course content, please post them in the forums to
get help from others in the course community.  For technical problems with the
Coursera platform, visit the Learner Help Center.

Good luck as you get started, and I hope you enjoy the course!

* Week 1---Introduction to Server-Side Development-NodeJS
:PROPERTIES:
:length:   10h 37m
:END:

{{{heading(Learning Objectives)}}}

- Describe the use of Node for server-side development
- Create a Node application
- Demonstrate the use of Node modules in developing a Node application
- Develop a simple REST API server using the Express framework


** Introduction to Server-Side Development with NodeJS, Express and MongoDB
:PROPERTIES:
:length:   10m
:END:

[[file:resources/week_1-lecture_01.mp4]]

** Introduction to the Learning Resources

[[file:resources/week_1-lecture_02.mp4]]

*** Additional Resources
- [[https://nodejs.org/][NodeJS]]

- [[https://www.npmjs.com/][NPM]]

- [[http://expressjs.com/][ExpressJS]]

- [[http://www.mongodb.org/][MongoDB]]

- [[http://mongoosejs.com/][Mongoose]]

** Introduciton to Full-Stack Web Development

{{{heading(The Big Picture---Objectives and Outcomes)}}}

This lesson gives you a big picture view of the Full Stack Web Development.
The lecture gives you an overview of full stack web development.  At the end of
this lesson, you will be able to:

- Understand what is meant by full stack in the context of web development

- Distinguish between front-end, back-end and full stack web development

- Understand the position of this course in the context of this specialization

- [[file:resources/week_1/lecture_03/index.mp4]]


{{{heading(Useful Links)}}}

- [[http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/][What is a Full Stack developer?]]

  A Full Stack Developer is someone with familiarity in each layer, if not
  mastery in many and a genuine interest in all software technology.  Good
  developers who are familiar with the entire stack know how to make life
  easier for those around them.

- [[http://edward-designer.com/web/full-stack-web-developer/][Wait, Wait… What is a Full-stack Web Developer After All?]]

- [[http://andyshora.com/full-stack-developers.html][The Myth of the Full-stack Developer]]

- [[https://en.wikipedia.org/wiki/Multitier_architecture][Multi-tier Architecture]]

- [[http://www.tonymarston.net/php-mysql/3-tier-architecture.html][What is the 3-Tier Architecture?]]

*** Layers of the Full Stack
1. Server, Network, and Hosting Environment.

   - This involves understanding what can break and why, taking no resource for
     granted.

   - Appropriate use of the file system, cloud storage, network resources, and
     an understanding of data redundancy and availability is necessary.

   - How does the application scale given the hardware constraints?

   - What about multi-threading and race  conditions? Guess what, you won’t see
     those on your development machine, but they  can and do happen in the real
     world.

   - Full stack developers can work side by side with DevOps.  The system
     should provide useful error messages and logging capabilities. DevOps will
     see the messages before you will, so make them count.

2. Data Modeling

   - If the data model is flawed, the business logic and higher layers start to
     need strange (ugly) code to compensate for corner cases the data model
     doesn’t cover.

   - Full stack developers know how to create a reasonably normalized
     relational model, complete with foreign keys, indexes, views, lookup
     tables, etc.

   - Full stack developers are familiar with the concept of non-relational data
     stores and understand where they shine over relational data stores.

3. Business Logic

   - The heart of the value the application provides.

   - Solid object oriented skills are needed here.

   - Frameworks might be needed here as well.

4. API layer---Action Layer---MVC

   - How the outside world operates against the business logic and data model.

   - Frameworks at this level should be used heavily.

   - Full stack developers have the ability to write clear, consistent, simple
     to use interfaces. The heights to which some APIs are convoluted repel me.

5. User Interface

   - Full stack developers: a) understand how to create a readable layout, or
     b) acknowledge they need help from artists and graphic designers.  Either
     way, implementing a good visual design is key.

   - Can include mastery of HTML5 / CSS.

   - JavaScript is the up and coming language of the future and lots of
     exciting work is being done in the JavaScript world (node, backbone,
     knockout…)

6. User Experience

   - Full stack developers appreciate that users just want things to work.

   - A good system doesn’t give its users carpal tunnel syndrome or sore eyes.
     A full stack developer can step back and look at a process that needs 8
     clicks and 3 steps, and get it down to one click.  Full stack developers
     write useful error messages. If something breaks, be apologetic about
     it. Sometimes programmers inadvertently write error messages that can make
     people feel stupid.

7. Understanding what the customer and the business need

   - Now we are blurring into the line of architect, but that is too much of a
     hands off role.

   - Full stack developers have a grasp of what is going on in the field when
     the customer uses the software. They also have a grasp of the business.

8. Other Pieces of the Puzzle

   - Ability to write quality unit tests.  By the way, even JavaScript can have
     unit tests these days.

   - Understanding of repeatable automated processes for building the
     application, testing it, documenting it, and deploying it at scale.

   - An awareness of security concerns is important, as each layer presents its
     own possible vulnerabilities.

9. Closing Thoughts

   - It is very bad practice to tightly couple code to a specific
     implementation (library, OS, hardware, etc). Just because a full stack
     developer understands the entire spectrum doesn’t mean they have license
     to take shortcuts. Well, actually they do if it is a build and throw away
     prototype.

   - Technology start-ups need full stack developers for their versatility!
     However, as an organization matures, it needs more and more focused
     skills.

   - I’m not sure you can call yourself a full stack developer until you have
     worked in multiple languages, platforms, and even industries in your
     professional career. Full stack goes beyond a ‘senior engineer’, as it is
     along the same lines as a polyglot programmer but with a higher view of
     all the connecting pieces. Note that on my list, only items 3-5 involve
     writing code.

*** What is a Full Stack Web Developer
:PROPERTIES:
:url:      https://edward-designer.com/web/full-stack-web-developer/
:author:   Edward Chung
:date:     December 18, 2014
:END:

**** Summary of What is a Full Stack Web Developer
A full-stack web developer is someone who has honed skills in both front-end
web design/development and back-end/server coding.  You can count on a
full-stack web developer to design, code, implement and maintain a fully
functional modern interactive website on his/her own (not just a static website
with a few pages).

**** The Full Stack Web Developer
With the ever evolvement of the almighty World Wide Web, new job functions are
created virtually every day.  Just a few years ago, you only needed a web
designer to create the visual design in Photoshop and/or Dreamweaver and a web
developer to code the front-end/back-end scripts and the website was ready to
go.  At that time, websites were charged based on the number of “pages” (a
concept borrowed from print design).

Fast forward to the present, we now have (not a exhaustive list) :

- visual designer
- web designer
- UI designer
- UX designer
- interaction designer
- art director
- front-end developer
- back-end developer
- web developer
- mobile developer
- database developer
- database administrator
- web master
- web server administrator
- SEO specialist
- web analyst
- web security professional
- quality assurance tester
- project manager
- growth hacker
- …


Several roles may be taken up by the same individual depending on the size of
the company and the resources.  Very large and profitable companies may gather
experts from each field in their teams with a view to create the
best-ever-possible web products of the world.

But normally, in the down-to-earth company, the web designer/developer
distinction still applies.  The web designer will be responsible for the
visual/web/UI/UX/interaction design while the web developer will do the
front-end coding/back-end coding/database administration/server
setup/debugging/etc.  However, problems always occur in areas when the two have
to work together yet only either one takes responsible.  Factors like
miscommunications/false assumptions of job role and scope/misunderstanding of
the technology/etc.  will render the end product a subpar one.

This is where a full-stack web developer can fill the gap.  A full-stack web
developer masters the best of both worlds (or to a minimum understands both
worlds).  (S)He will be able to steer the web projects in the right direction
utilizing the best practices and latest advancements in the technology.  (S)He
will design and code the whole web project themselves or supervise others to
perform the tasks by overlooking the whole process from scratch to finish.

When websites and web applications become more and more interactive and
sophisticated, understanding the technical capabilities of the systems and
having an eye for artistic/usability judgement are critical to the success.  So
it is natural for web professionals to evolve to full-stack web developers in
due course.

However, designing and coding are two distinct skills that require different
regions of the brain to master. The right brain is for visual and creativity
and the left brain is for structure and organization.  Designers are
predominately right-brainers while coder left-brainers.  So there is still only
a handful of full-stack web developer on the market.

{{{heading(Benefits of Being a Full-Stack Web Developer)}}}

1. You can build a professional website from scratches for your employer.

2. You can be a competent member in cross-functional Agile teams where you can
   perform both front-end and back-end development.  As Agile project
   management is fast becoming the norm for web application development and
   UI/UX is gaining in importance for the success or failure of any web
   application, you will be seen as a valuable team member contributing to the
   success of projects.

3. You can start your own website design and development business.

4. You can build your own websites and monetize them through Adsense, affiliate
   marketing, selling your own products and more.  The best of this is the
   flexibility of earning extra money alongside your regular job.  There are
   many great examples of web developers turning this business into a career
   and quitting their regular jobs.

*** The Myth of the Full-stack Developer
:PROPERTIES:
:url:      https://www.andyshora.com/full-stack-developers.html
:author:   Andy Shora
:END:

{{{heading(“Full Stack”)}}}

My defensive tendencies are normally put on high alert when I hear that magic
phrase.  Stacks are a lot bigger than what they used to be, and being able to
claim one has acquired refined skills at every layer of web development is
certainly not a small claim.  Does this mean you have a broad range of skills
or you specialise in everything?

For a time (allegedly) Facebook only hired full-stack engineers.  This was of
course when they were building the first few versions of Facebook, which, lets
face it had a relatively simple php backend and wasn't anything special
design-wise.

{{{heading(Full-stack used to mean less layers)}}}

Coding php or Python, jQuery, HTML, CSS then transferring a few files via FTP
to your shared hosting account or dedicated server? You were full-stack.  HTML
was trivial, and even thinking of implementing any proper application code in
JavaScript wasn't possible.

My beef is not with people who can do all of the above, it's with the label
'full-stack developer'.  What does it mean in 2014?

At the level of a senior full-stack engineer we're perhaps talking about
architecting a modular Backbone/AngularJS front-end whilst optimising content
delivery and tweaking hardware accelerated layers in CSS, followed by
implementing an async non-blocking backend (which also pre-renders templates on
the server), and pushing to an AWS cluster which has been built with security
and scaleability in mind.  Not to mention design.  Designing UI responsively
and mobile-first is essential, utilising a CSS pre-processor to save time.  And
remember to setup Nagios for monitoring.  Oh, and ideally when the Continuous
Integration server detects a bad build because your end-to-end tests have
failed, get it to send you an SMS with the build error messages.  Well, the
last two are probably for bonus points.

Ask someone who labels themselves 'full-stack'.  Do they believe they have
familiarity with different layers, or true mastery?

{{{heading(Identifying mastery)}}}

I used to work with a very smart guy who when interviewing junior web
developers, used to draw a spider diagram with each of the spikes being
different layers of web development; UX, HTML, CSS, JavaScript, backend
scripting language, and SQL.  When the young developers were asked to grade
themselves out of 10 for each of the skill areas, most went for a good spread,
but a rather high spread.  It seemed nobody wanted to exceed an 8, or drop
below a 5 in any of the layers.  We can ignore the scale at which they were
grading themselves, because we were simply interpreting the grades relatively
against each other so we could get a good idea of what kind of developer the
individual saw themselves as.  I didn't hear the term 'full-stack' being used
even once, but we got a feel that everyone was an all-round web developer.
What happened next was more interesting.

On the second iteration the interviewees were given a maximum of 30 points to
distribute as they pleased.  After some frowning, some internal arguing, and
finally the self-grading we saw a lot more skewed graphs.  The 7-5 well-spread
ratings turned into more skewed 8-2's.  It seemed when faced with the harsh
reality of admitting what they were really good at, they delivered, giving
themselves 8's in their favoured areas and 2's in others.  If the candidates
really believed in their initial relative spread, we would see the same
weighting in the second round, but instead we saw front-end and back-end
developers emerge from the crowd.

Of course 99% of web developers have probably never sat through this test, and
have perhaps have never been forced to reveal what their real spread of skills
is.

{{{heading(How skilled are you in each discipline?)}}}

The basics of the languages/frameworks we learn today can often be picked up in
a matter of hours.  We no longer add skills to our CVs by taking a course, we
simply download some code and start hacking through tutorials and demo code.
The problem is, I feel the difference between knowing something in web
development and truly mastering it is now becoming an increasingly blurred
line.

It's very easy to become disillusioned with your own skills when you've
deployed some code which has been consumed by lots of users.  Let's say you've
written a web application which has scaled well under load, and you've received
great feedback.  Are you a master of everything you used in this stack?  Or are
you simply good at implementing the layers you needed to make things work
together?  Because that's an entirely different skill, and in fact a very
valuable one.

{{{heading(The skill of acquiring new skills)}}}

In my eyes the most valuable skill to have is the ability to learn, closely
followed by the ability to know when you don't know something.  I'm sure we've
all met people who decide to put brakes on their own learning because they
believe they've become a master at something.  I don't know about you, but the
smartest people I know (and the ones I have most respect for) are the ones who
are still eager to learn new things every day, from everyone they meet.  These
people just don't stop growing, in terms of both ability and character.

{{{heading(Why I'm not a full-stack developer)}}}

At one point (probably when I was about twenty-two) I heard this phrase
'full-stack' and I thought "yeah, I'm one of them".  Five years later after
working in roles with ASP, php, .Net, Node and finally JavaScript and CSS, I
only label myself as a front-end developer.  Maybe I just wasn't that good at
previous disciplines, or maybe since spending the last 2-3 years in pure
JavaScript roles I just actually realised how high the limits are when you
specialise.  This is simply opportunity I did not have when I was busy in
cross-discipline roles at smaller companies.

Sure, I've got some broad skills like a lot of developers.  However, I'd like
to think being a front-end developer now assumes some knowledge of UX, design,
and how data is modelled and served on the backend, and this is why I think the
term full-stack is old fashioned (if five years is old) and perhaps a bit smug.

Maybe, I just don't like the term.

{{{heading(Some people are willing to have a go at everything)}}}

Perhaps most respectable about all people who claim to be full-stack, is that
is conveys ambition and persistance.  The ideal developer should be willing to
have a go at learning anything, but also acknowledge when they need help from a
specialist in the team.

Perhaps I was too defensive at first, I've met too many people who pronounce
the term in a smug way, instantly causing me to discredit them.  However, say
you're full-stack in a normal way, and there will be no scrutiny from my part.
It won't be at all like meeting an investment banker or recruiter.

{{{heading(The employability of a true full-stack developer: HIGH)}}}

The chances of finding a good full-stack developer: LOW.

Smaller companies and startups NEED full-stack developers.  Developers are
often forced to acquire new skills when the resources simply aren't available.
I feel the problem for companies desperate to hire these guys and girls, is
that the real multi-skilled developers are often lost in a sea of douchebags,
claiming they know it all.

*** Multi-tier Architecture
- https://en.wikipedia.org/wiki/Multitier_architecture


In software engineering, /multitier architecture/ (often referred to as /n-tier
architecture/) or /multilayered architecture/ is a *client–server architecture
in which presentation, application processing, and data management functions
are physically separated*.  The most widespread use of multitier architecture
is the /three-tier architecture/.

*** What is the 3-Tier Architecture
:PROPERTIES:
:url:      http://www.tonymarston.net/php-mysql/3-tier-architecture.html
:author:   Tony Marston
:date:     October 14, 2012
:END:

**** Introduction to What is the 3-Tier Architecture
This article is in response to [[http://blog.ircmaxell.com/2012/08/n-tier-architecture-introduction.html][N-Tier Architecture - An Introduction]] written by
Anthony Ferrara which I feel gives only a very limited view of what can be a
complex subject.  Different people have different ideas on how an application
can be split into tiers, and different ideas on the benefits which can be
gained from making such a split.  I have been designing and building
multi-tiered applications in different languages for over a decade, so my
exposure to this subject has been quite extensive.  I would like to share with
you my experiences on this subject and hopefully give you a more detailed
picture.

** Introduction to Git
*** Setting up Git

Git Objectives and Outcomes

At the end of this lesson you should have set up Git on your computer. At the
end of this lesson, you will be able to:

- Set up a Git repository and perform basic Git operations

- Set up and use online Git repositories

**** Setting up your Development Environment

{{{heading(Software Requirements)}}}

1. Text editor of your choice: Any text editor that you are already familiar
   with can be used for editing the project files.  I will be using Visual
   Studio Code (https://code.visualstudio.com/) as the editor of choice in this
   specialization.  You may also consider other editors such as Brackets
   (http://brackets.io/), Sublime Text (http://www.sublimetext.com/), or Atom
   (https://atom.io/).

2. Browser of your choice: You may use your preferred browser.  I will be using
   Chrome as the browser in all the exercises.  All the exercises and
   assignments in this course have been tested using Chrome v. 46.  Please note
   that not all browsers may support all the HTML5 features to the same extent.
   You might encounter problems when using other browsers.  I strongly urge you
   to use the latest Chrome browser for the exercises and assignments in this
   course so that any problems are minimized.

3. Command line shell: Familiarity with the command-line shell will be
   essential for the exercises.  In Windows a cmd window or power shell with
   admin privileges would be needed.  On a Mac or in Linux, a terminal window
   can be used.  Please get familiar with the "sudo" command in OS X and Linux.

4. Files required for the exercises: We will provide additional starter files
   for the exercises wherever needed.  Links to download the files will be
   provided inline in the exercise instructions that follow each exercise
   video.  Please download the files provided there, if any, before beginning
   the exercise.  The links are also available through the Additional Resources
   of the specific lesson.


*Note*: Please remember to retain the folders and all the files that you create
in the exercises.  Further exercises will build upon the files that you create
in the preceding exercises.  DO NOT DELETE the files at the end of the
exercises, unless otherwise instructed.  You may wish to set up your exercise
folder as a Git repository and commit the files to the repository at the end of
each exercise.  Brief instructions on using Git are available later in this
lesson.

**** Exercise---Video---Setting Up Git
- [[file:resources/week_1/lecture_04/index.mp4]]

**** Exercise---Setting Up Git

{{{heading(Objectives and Outcomes)}}}

In this exercise you will learn to install Git on your computer. Git is
required for using all the remaining Node.js and Node based tools that we
encounter in the rest of the course. At the end of this exercise, you would be
able to:

- Install Git on your computer

- Ensure that Git can be used from the command-line or command-prompt on your
  computer

- Set up some of the basic global configuration for Git


{{{heading(Downloading and Installing Git)}}}

- To install Git on your computer, go to https://git-scm.com/downloads to
  download the Git installer for your specific computing platform.

- Then, follow the installation steps as you install Git using the installer.

- You can find more details about installing Git at
  https://git-scm.com/book/en/v2/Getting-Started-Installing-Git. This document
  lists several ways of installing Git on various platforms.

- Installing some of the GUI tools like GitHub Desktop will also install Git on
  your computer.

- On a Mac, setting up XCode command-line tools also will set up Git on your
  computer.

- You can choose any of the methods that is most convenient for you.


{{{heading(Some Global Configuration for Git)}}}

- Open a cmd window or terminal on your computer.

- Check to make sure that Git is installed and available on the command line,
  by typing the following at the command prompt:
  : git --version

- To configure your user name to be used by Git, type the following at the
  prompt:
  : git config --global user.name "Your Name"

- To configure your email to be used by Git, type the following at the prompt:
  : git config --global user.email <your email address>

- You can check your default Git global configuration, you can type the
  following at the prompt:
  : git config --list

*** Basic Git Commands
- [[file:resources/week_1/lecture_05/index.mp4]]

- [[file:resources/week_1/lecture_05/Git-Exercises.pdf][Git-Exercises.pdf]]


{{{heading(Objectives and Outcomes)}}}

In this exercise you will get familiar with some basic Git commands. At the end
of this exercise you will be able to:

- Set up a folder as a Git repository

- Perform basic Git operations on your Git repository


{{{heading(Basic Git Commands)}}}

- At a convenient location on your computer, create a folder named git-test.

- Open this git-test folder in your favorite editor.

- Add a file named index.html to this folder, and add the following HTML code
  to this file:

  #+name:index.html-skeleton
  #+begin_src html
    <!DOCTYPE html>
    <html>
        <head></head>

        <body>
            <h1>This is a Header</h1>
        </body>
  #+end_src

{{{subheading(Initializing the folder as a Git repository)}}}

- Go to the git-test folder in your cmd window/terminal and type the following
  at the prompt to initialize the folder as a Git repository:
  : git init


{{{subheading(Checking your Git repository status)}}}

- Type the following at the prompt to check your Git repository's status:
  : git status


{{{subheading(Adding files to the staging area)}}}

- To add files to the staging area of your Git repository, type:
  : git add .


{{{subheading(Commiting to the Git repository)}}}

- To commit the current staging area to your Git repository, type:
  : git commit -m "first commit"


{{{subheading(Checking the log of Git commits)}}}

- To check the log of the commits to your Git repository, type
  : git log --oneline


{{{heading(Modifications)}}}

- Now, modify the ~index.html~ file as follows:

#+name:index.html-modification1
#+begin_src html
  !DOCTYPE html>
  <html>
      <head></head>

      <body>
          <h1>This is a Header</h1>
          <p>This is a paragraph</p>
      </body>
  </html>
#+end_src

- Add a sub-folder named templates to your git-test folder, and then add a file
  named temp.html to the templates folder. Then set the contents of this file
  to be the same as the index.html file above.

- Then check the status and add all the files to the staging area.

- Then do the second commit to your repository

- Now, modify the index.html file as follows:

#+name:index.html-modification2
#+begin_src html
  <!DOCTYPE html>
  <html>
      <head></head>

      <body>
          <h1>This is a Header</h1>
          <p>This is a paragraph</p>
          <p>This is a second paragraph</p>
      </body>
  </html>
#+end_src

- Now add the modified ~index.html~ file to the staging area and then do a third
  commit.


{{{subheading(Checking out a file from an earlier commit)}}}

- To check out the index.html from the second commit, find the number of the
  second commit using the git log, and then type the following at the prompt:
  : git checkout <second commit's number> index.html

{{{subheading(Resetting the Git repository)}}}

- To discard the effect of the previous operation and restore index.html to its
  state at the end of the third commit, type:
  : git reset HEAD index.html

- Then type the following at the prompt:
  : git checkout -- index.html

- You can also use ~git reset~ to reset the staging area to the last commit
  without disturbing the working directory.

*** Online Git Repositories
- [[file:resources/week_1/lecture_06/index.mp4]]

- [[file:resources/week_1/lecture_06/Git-Exercises.pdf][Git-Exercises.pdf]]


{{{heading(Objectives and Outcomes)}}}

In this exercise you will learn about how to set up and use an online Git
repository and synchronize your local Git repository with your online
repository. At the end of this exercise, you will be able to:

- Set up the online repository as a remote repository for your local Git
  repository

- Push your commits to the online repository

- Clone an online Git repository to your computer


{{{heading(Setting up an Online Git repository)}}}

- Sign up for an account either at Bitbucket (https://bitbucket.org) or GitHub
  (https://github.com). Note that private repositories on GitHub requires a
  paid account, and is not available for free accounts.

- Then set up an online Git repository named git-test. Note the URL of your
  online Git repository.


{{{heading(Set the local Git repository to set its remote origin)}}}

- At the prompt, type the following to set up your local repository to link to
  your online Git repository:
  : git remote add origin <repository URL>

{{{heading(Pushing your commits to the online repository)}}}

- At the prompt, type the following to push the commits to the online
  repository:
  : git push -u origin master

{{{heading(Cloning an online repository)}}}

- To clone an online repository to your computer, type the following at the
  prompt:
  : git clone <repository URL>

*** Additional Git Resources
- Git site http://git-scm.com.

- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][Installing Git]] chapter from Pro Git

- [[https://git-scm.com/docs][Git reference manual]]

- Quick reference guides:

  - [[https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf][GitHub Cheat Sheet]] (PDF)

  - [[http://ndpsoftware.com/git-cheatsheet.html][Visual Git Cheat Sheet]] (SVG | PNG)

- [[https://www.atlassian.com/git/tutorials/][Atlassian comprehensive Git tutorial]]

** Introduction to Node.js and NPM

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn the basics of Node.js and NPM. Thereafter, you
will install Node.js and NPM on your machine so that you can start writing
simple Node applications. At the end of this lesson, you should be able to:

- Download and install Node.js and NPM on your machine

- Verify that the installation was successful and your machine is ready for
  using Node.js and NPM.

*** About Node.js and NPM
- [[file:resources/week_1/lecture_07/index.mp4]]

- [[file:resources/week_1/lecture_07/NodeJS-NPM.pdf][NodeJS-NPM.pdf]]

*** Setting Up Node.js and NPM
- [[file:resources/week_1/lecture_08/index.mp4]]


*Note*: Make sure you have installed Git on your machine before you install
Node.js. Please complete the previous Git installation exercise before
proceeding with this exercise.

{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn to set up the Node.js environment, a popular
Javascript based server framework, and node package manager (NPM) on your
machine. To learn more about NodeJS, you can visit https://nodejs.org. For this
course, you need to install Node.js on your machine. At the end of this
exercise, you will be able to:

- Complete the set up of Node.js and NPM on your machine

- Verify that the installation was successful and your machine is ready for
  using Node.js and NPM.


{{{heading(Installing Node)}}}

- To install Node on your machine, go to https://nodejs.org and click on the
  Download button. Depending on your computer's platform (Windows, MacOS or
  Linux), the appropriate installation package is downloaded.

- As an example, on a Mac, you will see the following web page. Click on the
  Download button. Follow along the instructions to install Node on your
  machine. (Note: Now Node gives you the option of installing a mature and
  dependable LTS version and a more newer current version. You can install the
  current version. I will use this version in the course.)


{{{heading(Verifying the Node Installation)}}}

- Open a terminal window on your machine. If you are using a Windows machine,
  open a cmd window or PowerShell window with admin privileges.

- To ensure that your NodeJS setup is working correctly, type the following at
  the command prompt to check for the version of Node and NPM
  : node -v
  : npm -v

*** Additional Resources for Node.js and NPM
- [[https://nodejs.org/][Nodejs.org]]

- [[https://www.npmjs.com/][Npmjs.com]]

- [[https://nodejs.org/api/][Node API Documentation]]

- [[https://docs.npmjs.com/][NPM Documentation]]

** Introduction to Node Modules

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn to write Node applications. You will learn about
Node modules and how you can make use of them within your Node applications. At
the end of this lesson, you will be able to:

- Write simple Node applications and run them using Node

- Develop Node modules and use them within your Node applications

- Learn about using callbacks and handling errors within your Node application

*** Understanding Node Modules
- [[file:resources/week_1/lecture_09/index.mp4]]

- [[file:resources/week_1/lecture_09/Node-Modules.pdf][Node-Modules.pdf]]

**** Exercise in Understanding Node Modules
- [[file:resources/week_1/lecture_10/index.mp4]]


{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn about writing Node applications using
JavaScript and also learn about the basics of Node modules. At the end of this
exercise, you will be able to:

- Write a simple Node application in JavaScript.

- Understand the basics of Node modules and write simple file-based Node
  modules


{{{heading(Starting a Node Application)}}}

- Go to a convenient location on your computer and create a folder named
  NodeJS. Then move to this folder.

- Now create a folder named node-examples and then move into this folder.

- At the prompt, type the following to initialize a package.json file in the
  node-examples folder:
  : npm init

- Accept the standard defaults suggested and then update the package.json file
  until you end up with the file containing the following:

  #+name:default-package.json
  #+begin_src js
    {
      "name": "node-examples",
      "version": "1.0.0",
      "description": "Simple Node Examples",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "node index"
      },
      "author": "Jogesh Muppala",
      "license": "ISC"
    }
  #+end_src

- Create a file named ~index.js~ and add the following code to this file:

  #+name:basic-index.js
  #+begin_src js
    var rect = {
            perimeter: (x, y) => (2*(x+y)),
            area: (x, y) => (x*y)
    };

    function solveRect(l,b) {
        console.log("Solving for rectangle with l = " + l + " and b = " + b);

        if (l <= 0 || b <= 0) {
            console.log("Rectangle dimensions should be greater than zero:  l = "
                   + l + ",  and b = " + b);
        }
        else {
                console.log("The area of the rectangle is " + rect.area(l,b));
                console.log("The perimeter of the rectangle is " + rect.perimeter(l,b));
        }
    }

    solveRect(2,4);
    solveRect(3,5);
    solveRect(0,5);
    solveRect(-3,5);
  #+end_src

- To run the Node application, type the following at the prompt:
  : npm start

- To initialize a Git repository and add the current files in the folder to the
  repository, type the following at the prompt:
  : git init
  : git add .

- Then, do a Git commit with the message "Simple Node Example".


{{{heading(A Simple Node Module)}}}

- Now, create a file named ~rectangle.js~, and add the following code to it:

  #+name:rectangle.js
  #+begin_src js
    exports.perimeter =  (x, y) => (2*(x+y));

    exports.area = (x, y) => (x*y);
  #+end_src

- Then, update ~index.js~ as follows (place the following at the top if the
  file):
  : var rect = require('./rectangle');

- Run the Node application like before and observe that the result will be the
  same.

- Do a Git commit with the message "Simple Node Module".

*** Node Modules and Callbacks and Error Handling
- [[file:resources/week_1/lecture_11/index.mp4]]

- [[file:resources/week_1/lecture_11/Node-Callbacks-Error_Handling.pdf][Node-Callbacks-Error_Handling.pdf]]

- [[file:resources/week_1/lecture_12/index.mp4]]


{{{heading(Objectives and Outcomes)}}}

In this exercise, you will learn about callbacks, JavaScript closures and error
handling in Node applications. At the end of this exercise, you will be able
to:

- Using Callbacks in Node applications

- Error handling in Node applications


{{{heading(Using Callbacks and Error Handling)}}}

- Update ~rectangle.js~ as shown below:

  #+name:rectangle.js-updated
  #+begin_src js
    module.exports = (x,y,callback) => {
        if (x <= 0 || y <= 0)
            setTimeout(() => 
                callback(new Error("Rectangle dimensions should be greater than zero: l = "
                    + x + ", and b = " + y), 
                null),
                2000);
        else
            setTimeout(() => 
                callback(null, {
                    perimeter: () => (2*(x+y)),
                    area:() => (x*y)
                }), 
                2000);
    }
  #+end_src

- Then, update ~index.js~ as shown below:

  #+name:index.js-updated
  #+begin_src js
    function solveRect(l,b) {
        console.log("Solving for rectangle with l = "
                    + l + " and b = " + b);
        rect(l,b, (err,rectangle) => {
            if (err) {
                    console.log("ERROR: ", err.message);
                }
            else {
                console.log("The area of the rectangle of dimensions l = "
                    + l + " and b = " + b + " is " + rectangle.area());
                console.log("The perimeter of the rectangle of dimensions l = "
                    + l + " and b = " + b + " is " + rectangle.perimeter());
            }
        });
        console.log("This statement after the call to rect()");
    };
  #+end_src

- Run the Node application as before and see the result.

Do a Git commit with the message "Node Callbacks and Error Handling".

*** Node Modules Additional Resources

- [[https://nodejs.org/api/modules.html][Node Modules]]

- [[https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/][The Node.js Event Loop, Timers, and process.nextTick()]]

- [[http://www.commonjs.org/][CommonJS]]

- [[http://wiki.commonjs.org/wiki/Modules/1.1.1][CommonJS Module Format]]

- [[http://requirejs.org/][RequireJS]]

** Introduction to Node and HTTP

{{{heading(Objectives and Outcomes)}}}

In this lesson you will learn more about the Node HTTP core module.  You will
create a simple HTTP server using the Node HTTP module and serve HTML files
from a public folder.  Along the way you will learn about the fs and path Node
core modules.  At the end of this lesson, you will be able to:

- Create a simple HTTP server using the Node HTTP core module

- Create a web server to serve static HTML files from a folder

*** Introduction to Networking Essentials

- [[file:resources/week_1/lecture_13/index.mp4]]

- [[file:resources/week_1/lecture_13/Networking-Essentials.pdf][Networking-Essentials.pdf]]

*** Introduction to the HTTP Module

- [[file:resources/week_1/lecture_14/index.mp4]]

- [[file:resources/week_1/lecture_14/Node-HTTP.pdf][Node-HTTP.pdf]]

*** Exercise---Node and the HTTP Module

- [[file:resources/week_1/lecture_15/index.mp4]]

{{{heading(Objectives and Outcomes)}}}

In this exercise, you will explore three core Node modules: HTTP, fs and
path. At the end of this exercise, you will be able to:

- Implement a simple HTTP Server

- mplement a server that returns html files from a folder


**** A Simple HTTP Server
- Create a folder named node-http in the NodeJS folder and move into the
  folder.

- In the node-http folder, create a subfolder named public.

- At the prompt, type the following to initialize a package.json file in the
  node-examples folder:

  : npm init

- Accept the standard defaults suggested until you end up with a package.json
  file containing the following:

  #+begin_src js
    {
      "name": "node-http",
      "version": "1.0.0",
      "description": "Node HTTP Module Example",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "node index"
      },
      "author": "Jogesh Muppala",
      "license": "ISC"
    }
  #+end_src

- Create a file named ~index.js~ and add the following code to it:

  #+begin_src js
    const http = require('http');

    const hostname = 'localhost';
    const port = 3000;

    const server = http.createServer((req, res) => {
        console.log(req.headers);
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/html');
        res.end('<html><body><h1>Hello, World!</h1></body></html>');
    })

    server.listen(port, hostname, () => {
      console.log(`Server running at http://${hostname}:${port}/`);
    });
  #+end_src

- Start the server by typing the following at the prompt:

  : npm start

- Then you can type:

  :  http://localhost:3000

  {{{noindent}}}in your browser address bar and see the result.

- You can also use [[http://www.getpostman.com/][postman]] chrome extension to send requests to the server and
  see the response.  Alternately, you can download the stand-alone Postman tool
  from http://getpostman.com and install it on your computer.

- Initialize a Git repository, check in the files and do a Git commit with the
  message "Node HTTP Example 1".

**** Serving HTML Files

- In the ~public~ folder, create a file named ~index.html~ and add the
  following code to it:

  #+begin_src html
    <html>
      <title>This is aboutus.html</title>
      <body>
        <h1>Aboutus.html</h1>
        <p>This is the contents of the aboutus.html file</p>
      </body>
    </html>
  #+end_src

- Then update ~index.js~ as follows:

  #+begin_src js
    ...
    const fs = require('fs');
    const path = require('path');
    ...

    const server = http.createServer((req, res) => {
      console.log('Request for ' + req.url + ' by method ' + req.method);

      if (req.method == 'GET') {
        var fileUrl;
        if (req.url == '/') fileUrl = '/index.html';
        else fileUrl = req.url;

        var filePath = path.resolve('./public'+fileUrl);
        const fileExt = path.extname(filePath);
        if (fileExt == '.html') {
          fs.exists(filePath, (exists) => {
            if (!exists) {
              res.statusCode = 404;
              res.setHeader('Content-Type', 'text/html');
              res.end('<html><body><h1>Error 404: ' + fileUrl + 
                          ' not found</h1></body></html>');
              return;
            }
            res.statusCode = 200;
            res.setHeader('Content-Type', 'text/html');
            fs.createReadStream(filePath).pipe(res);
          });
        }
        else {
          res.statusCode = 404;
          res.setHeader('Content-Type', 'text/html');
          res.end('<html><body><h1>Error 404: ' + fileUrl + 
                  ' not a HTML file</h1></body></html>');
        }
      }
      else {
          res.statusCode = 404;
          res.setHeader('Content-Type', 'text/html');
          res.end('<html><body><h1>Error 404: ' + req.method + 
                  ' not supported</h1></body></html>');
      }
    })

    ...
  #+end_src

- Start the server, and send various requests to it and see the corresponding
  responses.

- Do a Git commit with the message "Node HTTP Example 2".

*** Node and HTTP Additional Resources

- [[https://nodejs.org/api/http.html][Node HTTP]]

- [[https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/][Anatomy of an HTTP Transaction]]

- [[https://nodejs.org/api/fs.html][fs Module]]

- [[https://nodejs.org/api/path.html][path Module]]

- [[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol][Hypertext Transfer Protocol]]

- [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes][List of HTTP Status Codes]]

- [[http://getpostman.com/][Postman]]

** Introduction to Express

*** Exercise---Introduction to Express

*** Brief Representational State Transfer---REST

*** Express Router

*** Exercice---Express Router

** Assignment 1---Node Modules Express and REST API
* Week 2---Persistent Storage with MongoDB
:PROPERTIES:
:length:   9h 12m
:END:

* Week 3---Security and Authentication
:PROPERTIES:
:length:   9h 26m
:END:

* Week 4---Backend as a Service BaaS
:PROPERTIES:
:length:   18h 8m
:END:

* Copying
:PROPERTIES:
:copying:  t
:END:

Copyright {{{noindent}}}\copy 2019 {{{author}}} {{{version}}}

* Footnotes

* Tables
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Table

* Programs
:PROPERTIES:
:index:    pg
:unnumbered: t
:END:

* Functions
:PROPERTIES:
:index:    fn
:unnumbered: t
:END:

* Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Definitions                                                      :noexport:
#+macro:heading @@html:<h2>@@@@texinfo:@heading@@ $1@@html:</h2>@@
#+macro:subheading @@html:<h3>@@@@texinfo:@heading@@ $1@@html:</h3>@@
#+macro:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro:noindent @@texinfo:@noindent @@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
#+macro:command @@texinfo:@command{@@$1@@texinfo:}@@
#+macro:option @@texinfo:@option{@@$1@@texinfo:}@@
#+macro:file @@texinfo:@file{@@$1@@texinfo:}@@

* Options                                                          :noexport:
#+options: H:4 ':t

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column: 79
# time-stamp-pattern: "8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# eval: (org-indent-mode)
# eval: (electric-quote-local-mode)
# End:
